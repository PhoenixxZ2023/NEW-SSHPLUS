#!/bin/bash
#====================================================
#	@TURBONET2023 
#====================================================
cor1='\033[41;1;37m'
cor2='\033[44;1;37m'
scor='\033[0m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
SCOLOR='\033[0m'
	ram1=$(free -h | grep -i mem | awk {'print $2'})
	ram2=$(free -h | grep -i mem | awk {'print $4'})
	ram3=$(free -h | grep -i mem | awk {'print $3'})
	uso=$(top -bn1 | awk '/Cpu/ { cpu = "" 100 - $8 "%" }; END { print cpu }')
	system=$(cat /etc/issue.net)
	fun_bar() {
		comando[0]="$1"
		comando[1]="$2"
		(
			[[ -e $HOME/fim ]] && rm $HOME/fim
			[[ ! -d /etc/SSHPlus ]] && rm -rf /bin/menu
			${comando[0]} >/dev/null 2>&1
			${comando[1]} >/dev/null 2>&1
			touch $HOME/fim
		) >/dev/null 2>&1 &
		tput civis
		echo -ne "\033[1;33mAGUARDE \033[1;37m- \033[1;33m["
		while true; do
			for ((i = 0; i < 18; i++)); do
				echo -ne "\033[1;31m#"
				sleep 0.1s
			done
			[[ -e $HOME/fim ]] && rm $HOME/fim && break
			echo -e "\033[1;33m]"
			sleep 1s
			tput cuu1
			tput dl1
			echo -ne "\033[1;33mAGUARDE \033[1;37m- \033[1;33m["
		done
		echo -e "\033[1;33m]\033[1;37m -\033[1;32m OK !\033[1;37m"
		tput cnorm
	}

	verif_ptrs() {
		porta=$1
		PT=$(lsof -V -i tcp -P -n | grep -v "ESTABLISHED" | grep -v "COMMAND" | grep "LISTEN")
		for pton in $(echo -e "$PT" | cut -d: -f2 | cut -d' ' -f1 | uniq); do
			svcs=$(echo -e "$PT" | grep -w "$pton" | awk '{print $1}' | uniq)
			[[ "$porta" = "$pton" ]] && {
				echo -e "\n\033[1;31mPORTA \033[1;33m$porta \033[1;31mEM USO PELO \033[1;37m$svcs\033[0m"
				sleep 3
				fun_conexao
			}
		done
	}

	slow_setup() {
		[[ -e "/bin/slowdns" ]] && {
			slowdns
		} || {
			cd $HOME
			rm -rf install; apt update; wget https://raw.githubusercontent.com/PhoenixxZ2023/NEW-SSHPLUS/main/Slowdns/install; chmod 777 install; ./install --start
		}

	}

	inst_sqd() {
		if netstat -nltp | grep 'squid' 1>/dev/null 2>/dev/null; then
			echo -e "\E[41;1;37m            REMOVER SQUID PROXY              \E[0m"
			echo ""
			echo -ne "\033[1;32mREALMENTE DESEJA REMOVER O SQUID \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read resp
			[[ "$resp" = 's' ]] && {
				echo -e "\n\033[1;32mREMOVENDO O SQUID PROXY !\033[0m"
				echo ""
				rem_sqd() {
					[[ -d "/etc/squid" ]] && {
						apt-get remove squid -y >/dev/null 2>&1
						apt-get purge squid -y >/dev/null 2>&1
						rm -rf /etc/squid >/dev/null 2>&1
					}
					[[ -d "/etc/squid3" ]] && {
						apt-get remove squid3 -y >/dev/null 2>&1
						apt-get purge squid3 -y >/dev/null 2>&1
						rm -rf /etc/squid3 >/dev/null 2>&1
						apt autoremove -y >/dev/null 2>&1
					}
				}
				fun_bar 'rem_sqd'
				echo -e "\n\033[1;32mSQUID REMOVIDO COM SUCESSO !\033[0m"
				sleep 2
				clear
				fun_conexao
			} || {
				echo -e "\n\033[1;31mRetornando...\033[0m"
				sleep 2
				clear
				fun_conexao
			}
		else
			clear
			echo -e "\E[44;1;37m              INSTALADOR SQUID                \E[0m"
			echo ""
			IP=$(wget -qO- ipv4.icanhazip.com)
			echo -ne "\033[1;32mPARA CONTINUAR CONFIRME SEU IP: \033[1;37m"
			read -e -i $IP ipdovps
			[[ -z "$ipdovps" ]] && {
				echo -e "\n\033[1;31mIP invalido\033[1;32m"
				echo ""
				read -p "Digite seu IP: " IP
			}
			echo -e "\n\033[1;33mQUAIS PORTAS DESEJA ULTILIZAR NO SQUID \033[1;31m?"
			echo -e "\n\033[1;33m[\033[1;31m!\033[1;33m] \033[1;32mDEFINA AS PORTAS EM SEQUENCIA \033[1;33mEX: \033[1;37m80 8080"
			echo ""
			echo -ne "\033[1;32mINFORME AS PORTAS\033[1;37m: "
			read portass
			[[ -z "$portass" ]] && {
				echo -e "\n\033[1;31mPorta invalida!"
				sleep 3
				fun_conexao
			}
			for porta in $(echo -e $portass); do
				verif_ptrs $porta
			done
			[[ $(grep -wc '14' /etc/issue.net) != '0' ]] || [[ $(grep -wc '8' /etc/issue.net) != '0' ]] && {
				echo -e "\n\033[1;32mINSTALANDO SQUID PROXY\033[0m\n"
				fun_bar 'apt update -y' "apt install squid3 -y"
			} || {
				echo -e "\n\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mSQUID VERSAO 3.3.X\n\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mSQUID VERSAO 3.5.X\033[0m\n"
				read -p "$(echo -e "\033[1;32mINFORME UMA OPÇÃO \033[1;37m: ")" -e -i 1 opc
				[[ -z "$opc" ]] && {
					echo -e "\n\033[1;31mOpcao invalida!"
					sleep 2
					fun_conexao
				}
				[[ "$opc" != '1' ]] && {
					[[ "$opc" != '2' ]] && {
						echo -e "\n\033[1;31mOpcao invalida !"
						sleep 2
						fun_conexao
					}
				}
				echo -e "\n\033[1;32mINSTALANDO SQUID PROXY\033[0m\n"
				fun_bar 'apt update -y' "instsqd $opc"
			}
			if [[ -d "/etc/squid/" ]]; then
				var_sqd="/etc/squid/squid.conf"
				var_pay="/etc/squid/payload.txt"
			elif [[ -d "/etc/squid3/" ]]; then
				var_sqd="/etc/squid3/squid.conf"
				var_pay="/etc/squid3/payload.txt"
			else
				echo -e "\n\033[1;33m[\033[1;31mERRO\033[1;33m]\033[1;37m: \033[1;33mO SQUID PROXY CORROMPEU\033[0m"
				sleep 2
				fun_conexao
			fi
			cat <<-EOF >$var_pay
				.whatsapp.net/
				.facebook.net/
				.twitter.com/
				.speedtest.net/
			EOF
			cat <<-EOF >$var_sqd
				acl url1 dstdomain -i 127.0.0.1
				acl url2 dstdomain -i localhost
				acl url3 dstdomain -i $ipdovps
				acl url4 dstdomain -i /SSHPLUS?
				acl payload url_regex -i "$var_pay"
				acl all src 0.0.0.0/0

				http_access allow url1
				http_access allow url2
				http_access allow url3
				http_access allow url4
				http_access allow payload
				http_access deny all
				 
				#Portas
			EOF
			for Pts in $(echo -e $portass); do
				echo -e "http_port $Pts" >>$var_sqd
				[[ -f "/usr/sbin/ufw" ]] && ufw allow $Pts/tcp
			done
			cat <<-EOF >>$var_sqd
				#Nome squid
				visible_hostname SSHPLUS 
				via off
				forwarded_for off
				pipeline_prefetch off
			EOF
			sqd_conf() {
				[[ -d "/etc/squid/" ]] && {
					service ssh restart
					/etc/init.d/squid restart
					service squid restart
				}
				[[ -d "/etc/squid3/" ]] && {
					service ssh restart
					/etc/init.d/squid3 restart
					service squid3 restart
				}
			}
			echo -e "\n\033[1;32mCONFIGURANDO SQUID PROXY\033[0m"
			echo ""
			fun_bar 'sqd_conf'
			echo -e "\n\033[1;32mSQUID INSTALADO COM SUCESSO!\033[0m"
			sleep 2.5s
			fun_conexao
		fi
	}

	addpt_sqd() {
		echo -e "\E[44;1;37m         ADICIONAR PORTA AO SQUID         \E[0m"
		echo -e "\n\033[1;33mPORTAS EM USO: \033[1;32m$sqdp\n"
		if [[ -f "/etc/squid/squid.conf" ]]; then
			var_sqd="/etc/squid/squid.conf"
		elif [[ -f "/etc/squid3/squid.conf" ]]; then
			var_sqd="/etc/squid3/squid.conf"
		else
			echo -e "\n\033[1;31mSQUID NAO ESTA INSTALADO!\033[0m"
			echo -e "\n\033[1;31mRetornando...\033[0m"
			sleep 2
			clear
			fun_squid
		fi
		echo -ne "\033[1;32mQUAL PORTA DESEJA ADICIONAR \033[1;33m?\033[1;37m "
		read pt
		[[ -z "$pt" ]] && {
			echo -e "\n\033[1;31mPorta invalida!"
			sleep 2
			clear
			fun_conexao
		}
		verif_ptrs $pt
		echo -e "\n\033[1;32mADICIONANDO PORTA AO SQUID!"
		echo ""
		sed -i "s/#Portas/#Portas\nhttp_port $pt/g" $var_sqd
		fun_bar 'sleep 2'
		echo -e "\n\033[1;32mREINICIANDO O SQUID!"
		echo ""
		fun_bar 'service squid restart' 'service squid3 restart'
		echo -e "\n\033[1;32mPORTA ADICIONADA COM SUCESSO!"
		sleep 3
		clear
		fun_squid
	}

	rempt_sqd() {
		echo -e "\E[41;1;37m        REMOVER PORTA DO SQUID        \E[0m"
		echo -e "\n\033[1;33mPORTAS EM USO: \033[1;32m$sqdp\n"
		if [[ -f "/etc/squid/squid.conf" ]]; then
			var_sqd="/etc/squid/squid.conf"
		elif [[ -f "/etc/squid3/squid.conf" ]]; then
			var_sqd="/etc/squid3/squid.conf"
		else
			echo -e "\n\033[1;31mSQUID NAO ESTA INSTALADO!\033[0m"
			echo -e "\n\033[1;31mRetornando...\033[0m"
			sleep 2
			clear
			fun_squid
		fi
		echo -ne "\033[1;32mQUAL PORTA DESEJA REMOVER \033[1;33m?\033[1;37m "
		read pt
		[[ -z "$pt" ]] && {
			echo -e "\n\033[1;31mPorta invalida!"
			sleep 2
			clear
			fun_conexao
		}
		if grep -E "$pt" $var_sqd >/dev/null 2>&1; then
			echo -e "\n\033[1;32mREMOVENDO PORTA DO SQUID!"
			echo ""
			sed -i "/http_port $pt/d" $var_sqd
			fun_bar 'sleep 3'
			echo -e "\n\033[1;32mREINICIANDO O SQUID!"
			echo ""
			fun_bar 'service squid restart' 'service squid3 restart'
			echo -e "\n\033[1;32mPORTA REMOVIDA COM SUCESSO!"
			sleep 3.5s
			clear
			fun_squid
		else
			echo -e "\n\033[1;31mPORTA \033[1;32m$pt \033[1;31mNAO ENCONTRADA!"
			sleep 3.5s
			clear
			fun_squid
		fi
	}

	fun_squid() {
		[[ "$(netstat -nplt | grep -c 'squid')" = "0" ]] && inst_sqd
		echo -e "\E[44;1;37m          GERENCIAR SQUID PROXY           \E[0m"
		[[ "$(netstat -nplt | grep -c 'squid')" != "0" ]] && {
			sqdp=$(netstat -nplt | grep 'squid' | awk -F ":" {'print $4'} | xargs)
			echo -e "\n\033[1;33mPORTAS\033[1;37m: \033[1;32m$sqdp"
			VarSqdOn="REMOVER SQUID PROXY"
		} || {
			VarSqdOn="INSTALAR SQUID PROXY"
		}
		echo -e "\n\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33m$VarSqdOn \033[1;31m
[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mADICIONAR PORTA \033[1;31m
[\033[1;36m3\033[1;31m] \033[1;37m• \033[1;33mREMOVER PORTA\033[1;31m
[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m"
		echo ""
		echo -ne "\033[1;32mOQUE DESEJA FAZER \033[1;33m?\033[1;31m?\033[1;37m "
		read x
		clear
		case $x in
		1 | 01)
			inst_sqd
			;;
		2 | 02)
			addpt_sqd
			;;
		3 | 03)
			rempt_sqd
			;;
		0 | 00)
			echo -e "\033[1;31mRetornando...\033[0m"
			sleep 1
			fun_conexao
			;;
		*)
			echo -e "\033[1;31mOpcao Invalida...\033[0m"
			sleep 2
			fun_conexao
			;;
		esac
	}

fun_drop() {
    if ss -nltp | grep 'dropbear' > /dev/null 2>&1; then
        # Script de gerenciamento do Dropbear quando ele já está instalado
        clear
        dpbr=$(ss -nltp | grep 'dropbear' | awk -F '[: ]+' '{print $5}' | xargs)
        if ps x | grep "limiter" | grep -v grep > /dev/null 2>&1; then
            stats='\033[1;32m◉ '
        else
            stats='\033[1;31m○ '
        fi
        echo -e "\E[44;1;37m              GERENCIAR DROPBEAR               \E[0m"
        echo -e "\n\033[1;33mPORTAS\033[1;37m: \033[1;32m$dpbr"
        echo ""
        echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mLIMITER DROPBEAR $stats\033[0m"
        echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mALTERAR PORTA DROPBEAR\033[0m"
        echo -e "\033[1;31m[\033[1;36m3\033[1;31m] \033[1;37m• \033[1;33mREMOVER DROPBEAR\033[0m"
        echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m"
        echo ""
        echo -ne "\033[1;32mO QUE DESEJA FAZER \033[1;33m?\033[1;37m "
        read resposta
        if [[ "$resposta" = '1' ]]; then
            # Controle de Limiter Dropbear
            clear
            if ps x | grep "limiter" | grep -v grep > /dev/null 2>&1; then
                echo -e "\033[1;32mPARANDO O LIMITER... \033[0m"
                echo ""
                fun_stplimiter() {
                    pidlimiter=$(ps x | grep "limiter" | awk -F "pts" '{print $1}' | xargs)
                    kill -9 $pidlimiter
                    screen -wipe
                }
                fun_bar 'fun_stplimiter' 'sleep 2'
                echo -e "\n\033[1;31m LIMITER DESATIVADO \033[0m"
                sleep 3
                fun_drop
            else
                echo -e "\n\033[1;32mINICIANDO O LIMITER... \033[0m"
                echo ""
                fun_bar 'screen -d -m -t limiter droplimiter' 'sleep 3'
                echo -e "\n\033[1;32m  LIMITER ATIVADO \033[0m"
                sleep 3
                fun_drop
            fi
        elif [[ "$resposta" = '2' ]]; then
            # Alterar Porta Dropbear sem validação
            echo ""
            echo -ne "\033[1;32mQUAL PORTA DESEJA UTILIZAR \033[1;33m?\033[1;37m "
            read pt
            var1=$(grep 'DROPBEAR_PORT=' /etc/default/dropbear | cut -d'=' -f2)
            echo -e "\033[1;32mALTERANDO PORTA DROPBEAR!"
            sed -i "s/\b$var1\b/$pt/g" /etc/default/dropbear >/dev/null 2>&1
            echo ""
            fun_bar 'sleep 2'
            echo -e "\n\033[1;32mREINICIANDO DROPBEAR!"
            echo ""
            fun_bar 'systemctl restart dropbear' 'sleep 2'
            echo -e "\n\033[1;32mPORTA ALTERADA COM SUCESSO!"
            sleep 3
            clear
            fun_conexao
        elif [[ "$resposta" = '3' ]]; then
            # Remover Dropbear
            echo -e "\n\033[1;32mREMOVENDO O DROPBEAR !\033[0m"
            echo ""
            fun_dropunistall() {
                systemctl stop dropbear && systemctl disable dropbear
                apt-get autoremove dropbear -y
                apt-get purge dropbear -y
                rm -rf /etc/default/dropbear
            }
            fun_bar 'fun_dropunistall' 'sleep 2'
            echo -e "\n\033[1;32mDROPBEAR REMOVIDO COM SUCESSO !\033[0m"
            sleep 3
            clear
            fun_conexao
        elif [[ "$resposta" = '0' ]]; then
            # Voltar
            echo -e "\n\033[1;31mRETORNANDO...\033[0m"
            sleep 2
            fun_conexao
        else
            # Opção Inválida
            echo -e "\n\033[1;31mOPÇÃO INVÁLIDA...\033[0m"
            sleep 2
            fun_conexao
        fi
    else
        # Instalar Dropbear versão 2024 no Ubuntu 20 e 22
        clear
        echo -e "\E[44;1;37m           INSTALADOR DROPBEAR VERSÃO 2024              \E[0m"
        echo -e "\n\033[1;33mVOCÊ ESTÁ PRESTES A INSTALAR O DROPBEAR VERSÃO 2024!\033[0m\n"
        echo -ne "\033[1;32mDESEJA CONTINUAR \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
        read resposta
        [[ "$resposta" = 's' ]] && {
            echo -e "\n\033[1;33mDEFINA UMA PORTA PARA O DROPBEAR!\033[0m\n"
            echo -ne "\033[1;32mQUAL A PORTA \033[1;33m?\033[1;37m "
            read porta
            echo -e "\n\033[1;32mREMOVENDO VERSÕES ANTIGAS DO DROPBEAR... \033[0m"
            echo ""
            fun_removedrop() {
                systemctl stop dropbear 2>/dev/null && systemctl disable dropbear 2>/dev/null
                apt-get autoremove dropbear -y 2>/dev/null
                apt-get purge dropbear -y 2>/dev/null
                rm -rf /etc/default/dropbear
            }
            fun_bar 'fun_removedrop' 'sleep 2'
            echo -e "\n\033[1;32mINSTALANDO O DROPBEAR VERSÃO 2024! \033[0m"
            echo ""
            # Instalar dependências necessárias
            apt-get install -y build-essential zlib1g-dev libssl-dev wget
            fun_instdrop() {
                wget --no-cache https://github.com/PhoenixxZ2023/dropbear-MOD/raw/main/install; chmod +x install; ./install
                chmod +x install.sh
                ./install.sh
            }
            fun_bar 'fun_instdrop' 'sleep 2'
            fun_ports() {
                sed -i 's/NO_START=1/NO_START=0/g' /etc/default/dropbear >/dev/null 2>&1
                sed -i "s/DROPBEAR_PORT=22/DROPBEAR_PORT=$porta/g" /etc/default/dropbear >/dev/null 2>&1
                systemctl restart dropbear
            }
            fun_bar 'fun_ports' 'sleep 2'
            echo -e "\n\033[1;32mDROPBEAR VERSÃO 2024 INSTALADO COM SUCESSO! \033[0m"
            sleep 3
            fun_conexao
        } || {
            echo -e "\n\033[1;31mINSTALAÇÃO CANCELADA!\033[0m"
            sleep 2
            fun_conexao
        }
    fi
}

	inst_ssl() {
		if netstat -nltp | grep 'stunnel4' 1>/dev/null 2>/dev/null; then
			[[ $(netstat -nltp | grep 'stunnel4' | wc -l) != '0' ]] && sslt=$(netstat -nplt | grep stunnel4 | awk {'print $4'} | awk -F ":" {'print $2'} | xargs) || sslt="\033[1;31mINDISPONIVEL"
			echo -e "\E[44;1;37m              GERENCIAR SSL STUNNEL4               \E[0m"
			echo -e "\n\033[1;33mPORTAS\033[1;37m: \033[1;32m$sslt"
			echo ""
			echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mALTERAR PORTA SSL TUNNEL\033[0m"
			echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mREMOVER SSL TUNNEL\033[0m"
			echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m"
			echo ""
			echo -ne "\033[1;32mOQUE DESEJA FAZER \033[1;33m?\033[1;37m "
			read resposta
			echo ""
			[[ "$resposta" = '1' ]] && {
				echo -ne "\033[1;32mQUAL PORTA DESEJA ULTILIZAR \033[1;33m?\033[1;37m "
				read porta
				echo ""
				[[ -z "$porta" ]] && {
					echo ""
					echo -e "\033[1;31mPorta invalida!"
					sleep 2
					clear
					fun_conexao
				}
				verif_ptrs $porta
				echo -e "\033[1;32mALTERANDO PORTA SSL TUNNEL!"
				var2=$(grep 'accept' /etc/stunnel/stunnel.conf | awk '{print $NF}')
				sed -i "s/\b$var2\b/$porta/g" /etc/stunnel/stunnel.conf >/dev/null 2>&1
				echo ""
				fun_bar 'sleep 2'
				echo ""
				echo -e "\033[1;32mREINICIANDO SSL TUNNEL!\n"
				fun_bar 'service stunnel4 restart' '/etc/init.d/stunnel4 restart'
				echo ""
				netstat -nltp | grep 'stunnel4' >/dev/null && echo -e "\033[1;32mPORTA ALTERADA COM SUCESSO !" || echo -e "\033[1;31mERRO INESPERADO!"
				sleep 3.5s
				clear
				fun_conexao
			}
			[[ "$resposta" = '2' ]] && {
				echo -e "\033[1;32mREMOVENDO O  SSL STUNNEL4 !\033[0m"
				del_ssl() {
					service stunnel4 stop
					apt-get remove stunnel4 -y
					apt-get autoremove stunnel4 -y
					apt-get purge stunnel4 -y
					rm -rf /etc/stunnel/stunnel.conf
					rm -rf /etc/default/stunnel4
					rm -rf /etc/stunnel/cert.cert
					rm -rf /etc/stunnel/key.key
				}
				echo ""
				fun_bar 'del_ssl'
				echo ""
				echo -e "\033[1;32mSSL TUNNEL REMOVIDO COM SUCESSO!\033[0m"
				sleep 3
				fun_conexao
			}
		else
			clear
			echo -e "\E[44;1;37m              INSTALAR SSL STUNNEL4               \E[0m"
			echo ""
			echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mINSTALAR SSL TUNNEL PADRÃO\033[0m"
			echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mINSTALAR SSL TUNNEL WEBSOCKET\033[0m"
			echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m"
			echo ""
			echo -ne "\033[1;32mOQUE DESEJA FAZER \033[1;33m?\033[1;37m "
			read resposta
			echo ""
			if [[ "$resposta" = '1' ]]; then
				portssl='22'
			elif [[ "$resposta" = '2' ]]; then
				portssl='80'
			elif [[ "$resposta" = '0' ]]; then
				echo -e "\033[1;31mRetornando...\033[0m"
				sleep 3
				fun_conexao
			else
				echo ""
				echo -e "\033[1;31mOpcao invalida !\033[0m"
				sleep 1
				inst_ssl
			fi
			clear
			echo -e "\E[44;1;37m           INSTALADOR SSL STUNNEL4             \E[0m"
			echo -e "\n\033[1;33mVC ESTA PRESTES A INSTALAR O SSL STUNNEL4 !\033[0m"
			echo ""
			echo -ne "\033[1;32mDESEJA CONTINUAR \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read resposta
			[[ "$resposta" = 's' ]] && {
				echo -e "\n\033[1;33mDEFINA UMA PORTA PARA O SSL TUNNEL !\033[0m"
				echo ""
				read -p "$(echo -e "\033[1;32mQUAL PORTA DESEJA UTILIZAR? \033[1;37m")" -e -i 443 porta
				[[ -z "$porta" ]] && {
					echo ""
					echo -e "\033[1;31mPorta invalida!"
					sleep 3
					clear
					fun_conexao
				}
				verif_ptrs $porta
				echo -e "\n\033[1;32mINSTALANDO O SSL TUNNEL !\033[1;33m"
				echo ""
				fun_bar 'apt-get update -y' 'apt-get install stunnel4 -y'
				echo -e "\n\033[1;32mCONFIGURANDO O SSL TUNNEL !\033[0m"
				echo ""
				ssl_conf() {
					echo -e "cert = /etc/stunnel/stunnel.pem\nclient = no\nsocket = a:SO_REUSEADDR=1\nsocket = l:TCP_NODELAY=1\nsocket = r:TCP_NODELAY=1\n\n[stunnel]\nconnect = 127.0.0.1:${portssl}\naccept = ${porta}" >/etc/stunnel/stunnel.conf
				}
				fun_bar 'ssl_conf'
				echo -e "\n\033[1;32mCRIANDO CERTIFICADO !\033[0m"
				echo ""
				ssl_certif() {
					crt='EC'
					openssl genrsa -out key.pem 2048 >/dev/null 2>&1
					(
						echo $crt
						echo $crt
						echo $crt
						echo $crt
						echo $crt
						echo $crt
						echo $crt
					) | openssl req -new -x509 -key key.pem -out cert.pem -days 1050 >/dev/null 2>&1
					cat cert.pem key.pem >>/etc/stunnel/stunnel.pem
					rm key.pem cert.pem >/dev/null 2>&1
					sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/stunnel4
				}
				fun_bar 'ssl_certif'
				echo -e "\n\033[1;32mINICIANDO O SSL TUNNEL !\033[0m"
				echo ""
				fun_finssl() {
					service stunnel4 restart
					service ssh restart
					/etc/init.d/stunnel4 restart
				}
				fun_bar 'fun_finssl' 'service stunnel4 restart'
				echo -e "\n\033[1;32mSSL TUNNEL INSTALADO COM SUCESSO !\033[1;31m PORTA: \033[1;33m$porta\033[0m"
				sleep 1
				clear
				echo -e "Corrigindo SSL CLARO"
				cd /etc/stunnel/
				rm -rf stunnel.conf
				rm -rf stunnel.pem
				wget https://raw.githubusercontent.com/PhoenixxZ2023/PLUS/main/Install/cert
				wget https://raw.githubusercontent.com/PhoenixxZ2023/PLUS/main/Install/key
				wget https://raw.githubusercontent.com/PhoenixxZ2023/PLUS/main/Install/stunnel
				mv cert cert.pem
				mv key key.pem
				mv stunnel stunnel.conf
				chmod 777 cert.pem
				chmod 777 key.pem
				chmod 777 stunnel.conf
				service stunnel4 restart
				cd $HOME
				clear
				echo -e "Corrigido"
				sleep 2
				fun_conexao
			} || {
				echo -e "\n\033[1;31mRetornando...\033[0m"
				sleep 2
				clear
				fun_conexao
			}
		fi
	}

inst_ssl5() {
    verif_ptrs() {
        local port=$1
        # ALTERADO: A verificação agora procura por 'stunnel5'
        if ss -tuln | grep -q ":$port " && ss -tulnp | grep -q "stunnel5"; then
            echo -e "\n\033[1;31mErro: A porta $port já está em uso pelo stunnel5 ou outro serviço!"
            echo -e "\033[1;33mServiço utilizando a porta:\033[0m"
            ss -tulnp | grep ":$port "
            sleep 3
            return 1
        elif ss -tuln | grep -q ":$port "; then
             echo -e "\n\033[1;31mErro: A porta $port já está em uso por outro serviço!"
            echo -e "\033[1;33mServiço utilizando a porta:\033[0m"
            ss -tulnp | grep ":$port "
            sleep 3
            return 1
        fi
        return 0
    }

    install_dependencies() {
        echo -e "\n\033[1;32mAtualizando pacotes e instalando dependências...\033[0m"
        apt-get update -y > /dev/null 2>&1
        apt-get install -y git build-essential libssl-dev autoconf automake libtool m4 autoconf-archive pkg-config > /dev/null 2>&1
        if [[ $? -ne 0 ]]; then
            echo -e "\033[1;31mErro fatal ao instalar dependências. Abortando.\033[0m"
            exit 1
        fi
    }

    # ALTERADO: Adicionado passo para renomear o binário
    compile_stunnel5() {
        echo -e "\033[1;32mClonando e compilando o stunnel 5.74...\033[0m"
        rm -rf /tmp/stunnel
        git clone https://github.com/mtrojnar/stunnel.git /tmp/stunnel > /dev/null 2>&1
        cd /tmp/stunnel || exit 1
        
        git checkout tags/stunnel-5.74 > /dev/null 2>&1
        if [[ $? -ne 0 ]]; then
            echo -e "\033[1;31mErro: Não foi possível encontrar a tag da versão 5.74 do stunnel.\033[0m"
            exit 1
        fi

        aclocal > /dev/null 2>&1
        autoreconf -fi > /dev/null 2>&1
        ./configure > /dev/null 2>&1
        make > /dev/null 2>&1
        make install > /dev/null 2>&1
        
        # --- PONTO CHAVE DA ALTERAÇÃO ---
        # Renomeia o binário para que o processo seja chamado de "stunnel5"
        mv /usr/local/bin/stunnel /usr/local/bin/stunnel5
        
        cd / # Retorna para o diretório raiz
        rm -rf /tmp/stunnel
        echo -e "\033[1;32mCompilação e instalação concluídas.\033[0m"
        echo -e "\033[1;33mBinário renomeado para 'stunnel5'.\033[0m"
    }

    ssl_conf() {
        local accept_port=$1
        local connect_port=$2
        mkdir -p /usr/local/etc/stunnel
        cat > /usr/local/etc/stunnel/stunnel.conf <<EOF
cert = /usr/local/etc/stunnel/stunnel.pem
client = no
pid = /usr/local/var/run/stunnel.pid
socket = a:SO_REUSEADDR=1
socket = l:TCP_NODELAY=1
socket = r:TCP_NODELAY=1

[stunnel5]
accept = ${accept_port}
connect = 127.0.0.1:${connect_port}
EOF
        echo -e "\033[1;32mArquivo de configuração criado.\033[0m"
    }

    ssl_certif() {
        echo -e "\033[1;32mGerando certificado SSL autoassinado...\033[0m"
        openssl req -new -x509 -days 3650 -nodes \
            -out /usr/local/etc/stunnel/stunnel.pem \
            -keyout /usr/local/etc/stunnel/stunnel.pem \
            -subj "/C=BR/ST=SaoPaulo/L=SaoPaulo/O=Private/OU=IT/CN=localhost" > /dev/null 2>&1
        chmod 777 /usr/local/etc/stunnel/stunnel.pem
        echo -e "\033[1;32mCertificado gerado com sucesso.\033[0m"
    }

    # ALTERADO: O serviço agora chama 'stunnel5'
    fun_finssl() {
        echo -e "\033[1;32mConfigurando o serviço systemd...\033[0m"
        mkdir -p /usr/local/var/run/
        chmod 777 /usr/local/var/run/
        chown root:root /usr/local/var/run/

        cat > /etc/systemd/system/stunnel5.service <<EOF
[Unit]
Description=stunnel5 TLS Tunneling Service
After=network.target

[Service]
Type=forking
# --- PONTO CHAVE DA ALTERAÇÃO ---
# Executa o binário renomeado
ExecStart=/usr/local/bin/stunnel5 /usr/local/etc/stunnel/stunnel.conf
PIDFile=/usr/local/var/run/stunnel.pid
Restart=always
TimeoutStartSec=300

[Install]
WantedBy=multi-user.target
EOF
        systemctl daemon-reload
        systemctl enable stunnel5 > /dev/null 2>&1
        systemctl restart stunnel5
        echo -e "\033[1;32mServiço stunnel5 iniciado e habilitado.\033[0m"
    }

    # ALTERADO: A desinstalação agora remove 'stunnel5'
    del_ssl() {
        echo -e "\033[1;32mParando e desabilitando o serviço...\033[0m"
        systemctl stop stunnel5 > /dev/null 2>&1
        systemctl disable stunnel5 > /dev/null 2>&1
        
        echo -e "\033[1;32mRemovendo arquivos...\033[0m"
        rm -f /etc/systemd/system/stunnel5.service
        systemctl daemon-reload
        systemctl reset-failed
        
        # --- PONTO CHAVE DA ALTERAÇÃO ---
        rm -f /usr/local/bin/stunnel5
        
        rm -rf /usr/local/etc/stunnel
        rm -f /usr/local/var/run/stunnel.pid
        rmdir /usr/local/var/run 2>/dev/null
        rm -rf /usr/local/lib/stunnel 2>/dev/null
        rm -rf /usr/local/share/stunnel 2>/dev/null
        rm -rf /usr/local/man/man8/stunnel* 2>/dev/null
    }

    # --- Lógica Principal do Script ---

    # ALTERADO: Verifica se o comando 'stunnel5' existe
    if command -v stunnel5 >/dev/null 2>&1 && [[ -f /etc/systemd/system/stunnel5.service ]]; then
        # Menu de Gerenciamento
        # ALTERADO: Agora o grep por 'stunnel5' vai funcionar corretamente
        sslt=$(ss -tlnp | grep 'stunnel5' | awk '{print $4}' | awk -F ":" '{print $NF}' | xargs)
        [[ -z "$sslt" ]] && sslt="\033[1;31mINDISPONÍVEL"

        clear
        echo -e "\E[44;1;37m          GERENCIAR SSL STUNNEL5          \E[0m"
        echo -e "\n\033[1;33mPORTAS EM USO\033[1;37m: \033[1;32m$sslt\033[0m"
        echo ""
        echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mALTERAR PORTA DO STUNNEL5\033[0m"
        echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mREMOVER O STUNNEL5\033[0m"
        echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mSAIR\033[0m"
        echo ""
        echo -ne "\033[1;32mO QUE DESEJA FAZER\033[1;33m? \033[1;37m"
        read -r resposta

        case "$resposta" in
            '1')
                echo ""
                read -p "$(echo -e '\033[1;32mQual a nova porta que deseja utilizar? \033[1;37m')" porta
                if [[ -z "$porta" || ! "$porta" =~ ^[0-9]+$ ]]; then
                    echo -e "\n\033[1;31mPorta inválida!\033[0m"; sleep 2; inst_ssl5; return
                fi
                
                verif_ptrs "$porta" || { inst_ssl5; return; }

                echo -e "\n\033[1;32mALTERANDO PORTA DO STUNNEL5...\033[0m"
                sed -i "s/accept = .*/accept = $porta/" /usr/local/etc/stunnel/stunnel.conf
                sleep 1
                echo -e "\033[1;32mREINICIANDO O SERVIÇO...\033[0m"
                systemctl restart stunnel5
                sleep 2
                
                # ALTERADO: Verificação agora usa 'stunnel5'
                if ss -tlnp | grep -q ":$porta.*stunnel5"; then
                    echo -e "\n\033[1;32mPORTA ALTERADA COM SUCESSO!\033[0m"
                else
                    echo -e "\n\033[1;31mERRO INESPERADO AO ALTERAR A PORTA!\033[0m"
                fi
                sleep 3
                inst_ssl5
                ;;
            '2')
                echo -e "\n\033[1;32mREMOVENDO O SSL STUNNEL5...\033[0m"; del_ssl
                echo -e "\n\033[1;32mSSL STUNNEL5 REMOVIDO COM SUCESSO!\033[0m"; sleep 3; inst_ssl5
                ;;
            '0')
                echo -e "\n\033[1;31mSaindo...\033[0m"; sleep 1; clear; exit 0
                ;;
            *)
                inst_ssl5
                ;;
        esac
    else
        # Menu de Instalação
        clear
        echo -e "\E[44;1;37m          INSTALAR SSL STUNNEL5           \E[0m"
        echo ""
        echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mSSL PADRÃO \033[0m"
        echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mSSL WEBSOCKET \033[0m"
        echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mSAIR\033[0m"
        echo ""
        echo -ne "\033[1;32mQUAL O MODO DE CONEXÃO DESEJADO\033[1;33m? \033[1;37m"
        read -r resposta

        case "$resposta" in
            '1') portssl='22' ;;
            '2') portssl='80' ;;
            '0') 
                echo -e "\n\033[1;31mSaindo...\033[0m"; sleep 1; clear; exit 0 ;;
            *)
                echo -e "\n\033[1;31mOpção inválida!\033[0m"; sleep 1; inst_ssl5; return ;;
        esac

        clear
        echo -e "\E[44;1;37m          INSTALADOR SSL STUNNEL5         \E[0m"
        echo -e "\n\033[1;33mVocê está prestes a compilar e instalar o stunnel 5.\033[0m"
        echo ""
        echo -ne "\033[1;32mDeseja continuar \033[1;31m? \033[1;33m[s/n]: \033[1;37m"
        read -r continuar
        
        if [[ "$continuar" =~ ^[Ss]$ ]]; then
            echo -e "\n\033[1;33mDEFINA UMA PORTA PARA O STUNNEL5 ESCUTAR\033[0m"
            read -p "$(echo -e '\033[1;32mQual porta deseja utilizar? \033[1;37m')" -e -i 443 porta
            
            if [[ -z "$porta" || ! "$porta" =~ ^[0-9]+$ ]]; then
                echo -e "\n\033[1;31mPorta inválida!\033[0m"; sleep 2; inst_ssl5; return
            fi

            verif_ptrs "$porta" || { inst_ssl5; return; }
            
            echo -e "\033[1;32m--- INICIANDO INSTALAÇÃO ---\033[0m"
            fun_bar install_dependencies; compile_stunnel5; ssl_conf "$porta" "$portssl"; ssl_certif; fun_finssl
            
            echo -e "\n\033[1;32m--- INSTALAÇÃO CONCLUÍDA ---\033[0m"
            # ALTERADO: Verificação final agora usa 'stunnel5'
            if ss -tlnp | grep -q ":$porta.*stunnel5"; then
                echo -e "\033[1;32mSSL STUNNEL5 instalado com sucesso na porta \033[1;33m$porta\033[0m"
            else
                echo -e "\033[1;31mO serviço foi instalado, mas não foi possível verificar a porta. Cheque o status com 'systemctl status stunnel5'.\033[0m"
            fi
            sleep 4
            inst_ssl5
        else
            echo -e "\n\033[1;31mInstalação cancelada. Retornando...\033[0m"; sleep 2; inst_ssl5
        fi
    fi
}

        ws_ssl() {
		rm -rf /root/*   && wget https://raw.githubusercontent.com/PhoenixxZ2023/PLUS/refs/heads/main/Modulos/ws_ssl_auto.sh && chmod +x ws_ssl_auto.sh && ./ws_ssl_auto.sh
		sleep 3
		fun_conexao
	}
	fun_ddos() {
		sudo apt install dnsutils
		apt-get install net-tools
		apt-get install tcpdump
		apt-get install unzip
		sudo apt-get install dsniff -y
		sudo apt install grepcidr
		wget https://github.com/jgmdev/ddos-deflate/archive/master.zip -O ddos.zip
		unzip ddos.zip
		cd ddos-deflate-master
		./install.sh
		sleep 9
		fun_conexao
	}

fun_openvpn() {
    # Verifica se o script está sendo executado com bash
    if readlink /proc/$$/exe | grep -qs "dash"; then
        echo "Este script precisa ser executado com bash, não sh"
        exit 1
    fi

    # Verifica se está sendo executado como root
    [[ "$EUID" -ne 0 ]] && {
        echo "Execute como root"
        exit 2
    }

    # Verifica se o dispositivo TUN/TAP está disponível
    [[ ! -e /dev/net/tun ]] && {
        echo -e "\033[1;31mTUN TAP NÃO DISPONÍVEL\033[0m"
        sleep 2
        exit 3
    }

    # Verifica se é CentOS 5 (muito antigo)
    if grep -qs "CentOS release 5" "/etc/redhat-release"; then
        echo "O CentOS 5 é muito antigo e não é suportado"
        exit 4
    fi

    # Detecta o sistema operacional e define variáveis
    if [[ -e /etc/debian_version ]]; then
        OS=debian
        GROUPNAME=nogroup
        RCLOCAL='systemd'
    elif [[ -e /etc/centos-release || -e /etc/redhat-release ]]; then
        OS=centos
        GROUPNAME=nobody
        RCLOCAL='/etc/rc.d/rc.local'
    else
        echo -e "SISTEMA NÃO SUPORTADO"
        exit 5
    fi

    # Configura iptables-legacy no Ubuntu, se disponível
    if [[ "$OS" = 'debian' ]] && command -v iptables-legacy >/dev/null; then
        update-alternatives --set iptables /usr/sbin/iptables-legacy >/dev/null 2>&1
    fi

    # Função para criar unidade systemd
    create_systemd_service() {
        cat <<-EOF >/etc/systemd/system/openvpn-startup.service
[Unit]
Description=Configurações de inicialização para OpenVPN
After=network.target

[Service]
Type=oneshot
ExecStart=/bin/sh -c "iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j SNAT --to $IP; \
    iptables -I INPUT -p $PROTOCOL --dport $porta -j ACCEPT; \
    iptables -I FORWARD -s 10.8.0.0/24 -j ACCEPT; \
    iptables -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT; \
    echo 1 > /proc/sys/net/ipv4/ip_forward; \
    echo 1 > /proc/sys/net/ipv6/conf/all/disable_ipv6; \
    iptables -A INPUT -p tcp --dport 25 -j DROP; \
    iptables -A INPUT -p tcp --dport 110 -j DROP; \
    iptables -A OUTPUT -p tcp --dport 25 -j DROP; \
    iptables -A OUTPUT -p tcp --dport 110 -j DROP; \
    iptables -A FORWARD -p tcp --dport 25 -j DROP; \
    iptables -A FORWARD -p tcp --dport 110 -j DROP"
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
        systemctl enable openvpn-startup.service >/dev/null 2>&1
        systemctl start openvpn-startup.service >/dev/null 2>&1
    }

    # Função para adicionar regras ao rc.local ou systemd
    add_startup_rules() {
        if [[ "$RCLOCAL" == "systemd" ]]; then
            create_systemd_service
        else
            echo '#!/bin/sh -e' > $RCLOCAL
            echo "iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j SNAT --to $IP" >> $RCLOCAL
            echo "iptables -I INPUT -p $PROTOCOL --dport $porta -j ACCEPT" >> $RCLOCAL
            echo "iptables -I FORWARD -s 10.8.0.0/24 -j ACCEPT" >> $RCLOCAL
            echo "iptables -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT" >> $RCLOCAL
            echo "echo 1 > /proc/sys/net/ipv4/ip_forward" >> $RCLOCAL
            echo "echo 1 > /proc/sys/net/ipv6/conf/all/disable_ipv6" >> $RCLOCAL
            echo "iptables -A INPUT -p tcp --dport 25 -j DROP" >> $RCLOCAL
            echo "iptables -A INPUT -p tcp --dport 110 -j DROP" >> $RCLOCAL
            echo "iptables -A OUTPUT -p tcp --dport 25 -j DROP" >> $RCLOCAL
            echo "iptables -A OUTPUT -p tcp --dport 110 -j DROP" >> $RCLOCAL
            echo "iptables -A FORWARD -p tcp --dport 25 -j DROP" >> $RCLOCAL
            echo "iptables -A FORWARD -p tcp --dport 110 -j DROP" >> $RCLOCAL
            echo "exit 0" >> $RCLOCAL
            chmod +x $RCLOCAL
        fi
    }

    # Função para gerar arquivo de cliente OVPN
    newclient() {
        cp /etc/SSHPlus/openvpn/client-common.txt ~/$1.ovpn
        echo "<ca>" >> ~/$1.ovpn
        cat /etc/SSHPlus/openvpn/ca.crt >> ~/$1.ovpn
        echo "</ca>" >> ~/$1.ovpn
        echo "<cert>" >> ~/$1.ovpn
        cat /etc/SSHPlus/openvpn/issued/$1.crt >> ~/$1.ovpn
        echo "</cert>" >> ~/$1.ovpn
        echo "<key>" >> ~/$1.ovpn
        cat /etc/SSHPlus/openvpn/private/$1.key >> ~/$1.ovpn
        echo "</key>" >> ~/$1.ovpn
        echo "<tls-crypt>" >> ~/$1.ovpn
        cat /etc/SSHPlus/openvpn/tc.key >> ~/$1.ovpn
        echo "</tls-crypt>" >> ~/$1.ovpn
    }

    # Determina o IP do servidor
    IP1=$(ip addr | grep 'inet' | grep -v inet6 | grep -vE '127\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | grep -o -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | head -1)
    IP2=$(wget -4qO- "http://whatismyip.akamai.com/" 2>/dev/null)
    [[ -z "$IP1" ]] && IP1=$(hostname -I | cut -d' ' -f1)
    [[ -n "$IP2" && "$IP1" != "$IP2" ]] && IP="$IP2" || IP="$IP1"

    # Função para verificar portas
    verif_ptrs() {
        local port=$1
        if netstat -tuln | grep -q ":$port "; then
            echo -e "\033[1;31mPorta $port já está em uso!\033[0m"
            sleep 2
            exit 1
        fi
    }

    # Função para configurar EasyRSA e gerar certificados/chaves
    fun_dep() {
        if ! command -v openvpn >/dev/null 2>&1; then
            echo -e "\033[1;31mOpenVPN não está instalado! Tentando reinstalar...\033[0m"
            if [[ "$OS" = 'debian' ]]; then
                apt-get update >/dev/null 2>&1
                apt-get install --reinstall openvpn -y >/dev/null 2>&1 || {
                    echo -e "\033[1;31mFalha ao reinstalar OpenVPN!\033[0m"
                    exit 1
                }
            else
                yum install openvpn -y >/dev/null 2>&1 || {
                    echo -e "\033[1;31mFalha ao reinstalar OpenVPN!\033[0m"
                    exit 1
                }
            fi
        fi

        echo -e "\033[1;32mConfigurando EasyRSA...\033[0m"
        rm -rf /etc/SSHPlus/openvpn/easy-rsa/ || {
            echo -e "\033[1;31mFalha ao remover EasyRSA antigo!\033[0m"
            exit 1
        }

        mkdir -p /etc/SSHPlus/openvpn/easy-rsa/ || {
            echo -e "\033[1;31mFalha ao criar diretório EasyRSA!\033[0m"
            exit 1
        }
        cd /etc/SSHPlus/openvpn/easy-rsa/ || {
            echo -e "\033[1;31mFalha ao acessar diretório EasyRSA!\033[0m"
            exit 1
        }

        fun_bar "wget -q https://github.com/OpenVPN/easy-rsa/releases/download/v3.2.3/EasyRSA-3.2.3.tgz" "Baixando EasyRSA 3.2.3"
        tar xzf EasyRSA-3.2.3.tgz --strip-components=1 || {
            echo -e "\033[1;31mFalha ao extrair EasyRSA!\033[0m"
            exit 1
        }
        rm EasyRSA-3.2.3.tgz || {
            echo -e "\033[1;31mFalha ao remover arquivo compactado!\033[0m"
            exit 1
        }
        chown -R root:root /etc/SSHPlus/openvpn/easy-rsa/ || {
            echo -e "\033[1;31mFalha ao ajustar permissões do EasyRSA!\033[0m"
            exit 1
        }

        echo -e "\033[1;32mInicializando PKI...\033[0m"
        ./easyrsa init-pki >/dev/null 2>&1 || {
            echo -e "\033[1;31mFalha ao inicializar PKI!\033[0m"
            exit 1
        }
        echo -e "\033[1;32mGerando CA...\033[0m"
        ./easyrsa --batch build-ca nopass >/dev/null 2>&1 || {
            echo -e "\033[1;31mFalha ao criar CA!\033[0m"
            exit 1
        }
        echo -e "\033[1;32mGerando chave TLS-Crypt...\033[0m"
        ./easyrsa gen-tls-crypt-key >/dev/null 2>&1 || {
             echo -e "\033[1;31mFalha ao gerar chave TLS-Crypt!\033[0m"
            exit 1
        }
        echo -e "\033[1;32mConfigurando parâmetros Diffie-Hellman...\033[0m"
        echo '-----BEGIN DH PARAMETERS-----
MIIBCAKCAQEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz
+8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a
87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7
YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi
7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaD
ssbzSibBsu/6iGtCOGEoXJf//////////wIBAg==
-----END DH PARAMETERS-----' > /etc/SSHPlus/openvpn/dh.pem

        echo -e "\033[1;32mGerando certificado do servidor...\033[0m"
        ./easyrsa --batch build-server-full server nopass >/dev/null 2>&1 || {
            echo -e "\033[1;31mFalha ao criar certificado do servidor!\033[0m"
            exit 1
        }
        echo -e "\033[1;32mGerando certificado do cliente...\033[0m"
        ./easyrsa --batch build-client-full SSHPLUS nopass >/dev/null 2>&1 || {
            echo -e "\033[1;31mFalha ao criar certificado do cliente!\033[0m"
            exit 1
        }
        echo -e "\033[1;32mGerando lista de revogação de certificados (CRL)...\033[0m"
        ./easyrsa gen-crl >/dev/null 2>&1 || {
            echo -e "\033[1;31mFalha ao gerar CRL!\033[0m"
            exit 1
        }

        echo -e "\033[1;32mCopiando certificados e chaves...\033[0m"
        cp pki/ca.crt pki/issued/server.crt pki/private/server.key pki/crl.pem /etc/SSHPlus/openvpn/ || {
            echo -e "\033[1;31mFalha ao copiar arquivos do servidor!\033[0m"
            exit 1
        }
        cp pki/private/easyrsa-tls.key /etc/SSHPlus/openvpn/tc.key || {
            echo -e "\033[1;31mFalha ao copiar tc.key!\033[0m"
            exit 1
        }

        echo -e "\033[1;32mAjustando permissões...\033[0m"
        chown nobody:$GROUPNAME /etc/SSHPlus/openvpn/crl.pem || {
            echo -e "\033[1;31mFalha ao ajustar dono do crl.pem!\033[0m"
            exit 1
        }
        chown root:root /etc/SSHPlus/openvpn/{ca.crt,server.crt,server.key,dh.pem,tc.key} || {
            echo -e "\033[1;31mFalha ao ajustar dono dos arquivos!\033[0m"
            exit 1
        }
        chmod 644 /etc/SSHPlus/openvpn/{ca.crt,server.crt,dh.pem,tc.key,crl.pem} || {
            echo -e "\033[1;31mFalha ao ajustar permissões!\033[0m"
            exit 1
        }
        chmod 600 /etc/SSHPlus/openvpn/server.key || {
            echo -e "\033[1;31mFalha ao ajustar permissões do server.key!\033[0m"
            exit 1
        }

        echo -e "\033[1;32mConfigurando server.conf...\033[0m"
        [[ ! -d /etc/SSHPlus/openvpn ]] && mkdir -p /etc/SSHPlus/openvpn
        PAM_PLUGIN=$(find /usr -type f -name 'openvpn-plugin-auth-pam.so' 2>/dev/null)
        [[ -z "$PAM_PLUGIN" ]] && {
            echo -e "\033[1;31mPlugin openvpn-plugin-auth-pam.so não encontrado! Instalando...\033[0m"
            apt-get install openvpn-auth-pam -y >/dev/null 2>&1
            PAM_PLUGIN=$(find /usr -type f -name 'openvpn-plugin-auth-pam.so' 2>/dev/null)
            [[ -z "$PAM_PLUGIN" ]] && {
                echo -e "\033[1;31mFalha ao instalar plugin PAM!\033[0m"
                exit 1
            }
        }
        cat << EOF > /etc/SSHPlus/openvpn/server.conf
port $porta
proto $PROTOCOL
dev tun
sndbuf 0
rcvbuf 0
ca ca.crt
cert server.crt
key server.key
dh dh.pem
auth SHA512
tls-crypt tc.key
topology subnet
server 10.8.0.0 255.255.255.0
ifconfig-pool-persist ipp.txt
push "redirect-gateway def1 bypass-dhcp"
push "block-outside-dns"
$(case $DNS in
    1) grep -v '#' /etc/resolv.conf | grep 'nameserver' | grep -E -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | while read line; do echo "push \"dhcp-option DNS $line\""; done ;;
    2) echo -e 'push "dhcp-option DNS 8.8.8.8"\npush "dhcp-option DNS 8.8.4.4"' ;;
    3) echo -e 'push "dhcp-option DNS 208.67.222.222"\npush "dhcp-option DNS 208.67.220.220"' ;;
    4) echo 'push "dhcp-option DNS 1.1.1.1"\npush "dhcp-option DNS 1.0.0.1"' ;;
    5) echo 'push "dhcp-option DNS 74.82.42.42"' ;;
    6) echo -e 'push "dhcp-option DNS 64.6.64.6"\npush "dhcp-option DNS 64.6.65.6"' ;;
    7) echo -e 'push "dhcp-option DNS 156.154.70.1"\npush "dhcp-option DNS 156.154.71.1"' ;;
esac)
keepalive 10 120
float
cipher AES-256-GCM
user nobody
group $GROUPNAME
persist-key
persist-tun
status openvpn-status.log
management localhost 7505
verb 3
crl-verify crl.pem
client-to-client
verify-client-cert none
username-as-common-name
plugin $PAM_PLUGIN login
duplicate-cn
EOF

        echo -e "\033[1;32mAjustando serviço systemd...\033[0m"
        cat << EOF > /lib/systemd/system/openvpn-server@.service
[Unit]
Description=OpenVPN service for %I
After=network-online.target
Wants=network-online.target
Documentation=man:openvpn(8)
Documentation=https://openvpn.net/community-resources/reference-manual-for-openvpn-2-6/
Documentation=https://community.openvpn.net/openvpn/wiki/HOWTO

[Service]
Type=notify
PrivateTmp=true
WorkingDirectory=/etc/SSHPlus/openvpn
ExecStart=/usr/sbin/openvpn --status %t/openvpn-server/status-%i.log --status-version 2 --suppress-timestamps --config /etc/SSHPlus/openvpn/%i.conf
CapabilityBoundingSet=CAP_IPC_LOCK CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW CAP_SETGID CAP_SETUID CAP_SETPCAP CAP_SYS_CHROOT CAP_DAC_OVERRIDE CAP_AUDIT_WRITE
LimitNPROC=10
DeviceAllow=/dev/null rw
DeviceAllow=/dev/net/tun rw
ProtectSystem=true
ProtectHome=true
KillMode=process
RestartSec=5s
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF
        systemctl daemon-reload >/dev/null 2>&1

        sed -i '/\<net.ipv4.ip_forward\>/c\net.ipv4.ip_forward=1' /etc/sysctl.conf
        if ! grep -q "\<net.ipv4.ip_forward\>" /etc/sysctl.conf; then
            echo 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf
        fi
        echo 1 > /proc/sys/net/ipv4/ip_forward
        if pgrep firewalld; then
            firewall-cmd --zone=public --add-port=$porta/$PROTOCOL >/dev/null 2>&1
            firewall-cmd --zone=trusted --add-source=10.8.0.0/24 >/dev/null 2>&1
            firewall-cmd --permanent --zone=public --add-port=$porta/$PROTOCOL >/dev/null 2>&1
            firewall-cmd --permanent --zone=trusted --add-source=10.8.0.0/24 >/dev/null 2>&1
        fi
        if iptables -L -n | grep -qE 'REJECT|DROP|ACCEPT'; then
            iptables -I INPUT -p $PROTOCOL --dport $porta -j ACCEPT >/dev/null 2>&1
            iptables -I FORWARD -s 10.8.0.0/24 -j ACCEPT >/dev/null 2>&1
            iptables -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT >/dev/null 2>&1
        fi
        iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j SNAT --to $IP >/dev/null 2>&1
        add_startup_rules
        if hash sestatus 2>/dev/null; then
            if sestatus | grep "Current mode" | grep -qs "enforcing"; then
                if [[ "$porta" != '1194' || "$PROTOCOL" = 'tcp' ]]; then
                    if ! hash semanage 2>/dev/null; then
                        apt-get install policycoreutils-python-utils -y >/dev/null 2>&1
                    fi
                    semanage port -a -t openvpn_port_t -p $PROTOCOL $porta >/dev/null 2>&1
                fi
            fi
        fi
    }

    # Função para remover OpenVPN
    rmv_open() {
        PORT=${PORT:-1194}
        PROTOCOL=${PROTOCOL:-tcp}
        IP=${IP:-$(ip addr | grep 'inet' | grep -v inet6 | grep -vE '127\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | grep -o -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | head -1)}

        if [[ -f /etc/SSHPlus/openvpn/server.conf ]]; then
            PORT=$(grep '^port ' /etc/SSHPlus/openvpn/server.conf | cut -d " " -f 2)
            PROTOCOL=$(grep '^proto ' /etc/SSHPlus/openvpn/server.conf | cut -d " " -f 2)
        fi

        if pgrep firewalld >/dev/null 2>&1; then
            firewall-cmd --zone=public --remove-port=$PORT/$PROTOCOL >/dev/null 2>&1
            firewall-cmd --zone=trusted --remove-source=10.8.0.0/24 >/dev/null 2>&1
            firewall-cmd --permanent --zone=public --remove-port=$PORT/$PROTOCOL >/dev/null 2>&1
            firewall-cmd --permanent --zone=trusted --remove-source=10.8.0.0/24 >/dev/null 2>&1
        fi

        if iptables -L -n >/dev/null 2>&1; then
            iptables -D INPUT -p $PROTOCOL --dport $PORT -j ACCEPT >/dev/null 2>&1
            iptables -D FORWARD -s 10.8.0.0/24 -j ACCEPT >/dev/null 2>&1
            iptables -D FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT >/dev/null 2>&1
            iptables -t nat -D POSTROUTING -s 10.8.0.0/24 -j SNAT --to $IP >/dev/null 2>&1
        fi

        if [[ "$RCLOCAL" == "systemd" ]]; then
            systemctl disable openvpn-startup.service >/dev/null 2>&1
            rm -f /etc/systemd/system/openvpn-startup.service >/dev/null 2>&1
            systemctl daemon-reload >/dev/null 2>&1
        elif [[ -f "$RCLOCAL" ]]; then
            sed -i "/iptables -t nat -A POSTROUTING -s 10.8.0.0\/24 -j SNAT --to /d" $RCLOCAL 2>/dev/null
            sed -i "/iptables -I INPUT -p $PROTOCOL --dport $PORT -j ACCEPT/d" $RCLOCAL 2>/dev/null
            sed -i "/iptables -I FORWARD -s 10.8.0.0\/24 -j ACCEPT/d" $RCLOCAL 2>/dev/null
            sed -i "/iptables -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT/d" $RCLOCAL 2>/dev/null
        fi

        if hash sestatus 2>/dev/null; then
            if sestatus | grep "Current mode" | grep -qs "enforcing"; then
                if [[ "$PORT" != '1194' || "$PROTOCOL" = 'tcp' ]]; then
                    semanage port -d -t openvpn_port_t -p $PROTOCOL $PORT >/dev/null 2>&1
                fi
            fi
        fi

        if [[ "$OS" = 'debian' ]]; then
            fun_bar "apt-get remove --purge -y openvpn" "Removendo pacotes OpenVPN"
            apt-get autoremove -y >/dev/null 2>&1
        else
            fun_bar "yum remove openvpn -y" "Removendo pacotes OpenVPN"
        fi
        rm -rf /etc/SSHPlus/openvpn >/dev/null 2>&1
        rm -rf /usr/share/doc/openvpn* >/dev/null 2>&1
        echo -e "\033[1;32mOPENVPN REMOVIDO COM SUCESSO!\033[0m"
    }

    # Menu principal
    if [[ $(netstat -nplt | grep -wc 'openvpn') != '0' ]]; then
        while :; do
            clear
            opnp=$(cat /etc/SSHPlus/openvpn/server.conf | grep "port" | awk '{print $2}' 2>/dev/null || echo "N/A")
            [[ -d /var/www/html/openvpn ]] && ovpnweb="\033[1;32m◉ " || ovpnweb="\033[1;31m○ "
            if grep "duplicate-cn" /etc/SSHPlus/openvpn/server.conf >/dev/null 2>&1; then
                mult="\033[1;32m◉ "
            else
                mult="\033[1;31m○ "
            fi
            echo -e "\E[44;1;37m         GERENCIAR OPENVPN           \E[0m"
            echo ""
            echo -e "\033[1;33mPORTA\033[1;37m: \033[1;32m$opnp"
            echo ""
            echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mALTERAR PORTA"
            echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mREMOVER OPENVPN"
            echo -e "\033[1;31m[\033[1;36m3\033[1;31m] \033[1;37m• \033[1;33mOVPN VIA LINK $ovpnweb"
            echo -e "\033[1;31m[\033[1;36m4\033[1;31m] \033[1;37m• \033[1;33mMULTILOGIN OVPN $mult"
            echo -e "\033[1;31m[\033[1;36m5\033[1;31m] \033[1;37m• \033[1;33mALTERAR HOST DNS"
            echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR"
            echo ""
            echo -ne "\033[1;32mO QUE DESEJA FAZER \033[1;33m?\033[1;31m?\033[1;37m "
            read option
            case $option in
                1)
                    clear
                    echo -e "\E[44;1;37m       ALTERAR PORTA OPENVPN         \E[0m"
                    echo ""
                    echo -e "\033[1;33mPORTA EM USO: \033[1;32m$opnp"
                    echo ""
                    echo -ne "\033[1;32mQUAL PORTA DESEJA UTILIZAR \033[1;33m?\033[1;37m "
                    read porta
                    [[ -z "$porta" ]] && {
                        echo ""
                        echo -e "\033[1;31mPorta inválida!"
                        sleep 3
                        continue
                    }
                    verif_ptrs $porta
                    echo ""
                    echo -e "\033[1;32mALTERANDO A PORTA OPENVPN!\033[1;33m"
                    echo ""
                    fun_opn() {
                        var_ptovpn=$(sed -n '1 p' /etc/SSHPlus/openvpn/server.conf)
                        sed -i "s/\b$var_ptovpn\b/port $porta/g" /etc/SSHPlus/openvpn/server.conf
                        sleep 1
                        var_ptovpn2=$(sed -n '7 p' /etc/SSHPlus/openvpn/client-common.txt | awk '{print $NF}')
                        sed -i "s/\b$var_ptovpn2\b/$porta/g" /etc/SSHPlus/openvpn/client-common.txt
                        sleep 1
                        systemctl restart openvpn-server@server.service >/dev/null 2>&1
                    }
                    fun_opn
                    echo ""
                    echo -e "\033[1;32mPORTA ALTERADA COM SUCESSO!\033[1;33m"
                    sleep 2
                    continue
                    ;;
                2)
                    echo ""
                    echo -ne "\033[1;32mDESEJA REMOVER O OPENVPN \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
                    read REMOVE
                    [[ "$REMOVE" = 's' ]] && {
                        echo ""
                        echo -e "\033[1;32mREMOVENDO O OPENVPN!\033[0m"
                        echo ""
                        rmv_open
                        sleep 2
                        exit 0
                    } || {
                        echo ""
                        echo -e "\033[1;31mRetornando...\033[0m"
                        sleep 2
                        continue
                    }
                    ;;
                3)
                    [[ -d /var/www/html/openvpn ]] && {
                        clear
                        fun_spcr() {
                            apt-get remove apache2 -y >/dev/null 2>&1
                            apt-get autoremove -y >/dev/null 2>&1
                            rm -rf /var/www/html/openvpn >/dev/null 2>&1
                        }
                        echo -ne "\033[1;31mDESATIVANDO\033[1;32m.\033[1;33m.\033[1;31m. \033[1;33m"
                        fun_spcr
                        echo -e "\e[1DOk"
                        sleep 2
                        continue
                    } || {
                        clear
                        fun_apchon() {
                            apt-get install apache2 zip -y >/dev/null 2>&1
                            sed -i "s/Listen 80/Listen 81/g" /etc/apache2/ports.conf >/dev/null 2>&1
                            service apache2 restart >/dev/null 2>&1
                            [[ ! -d /var/www/html ]] && mkdir /var/www/html
                            [[ ! -d /var/www/html/openvpn ]] && mkdir /var/www/html/openvpn
                            touch /var/www/html/openvpn/index.html
                            chmod -R 755 /var/www >/dev/null 2>&1
                            /etc/init.d/apache2 restart >/dev/null 2>&1
                        }
                        echo -ne "\033[1;32mATIVANDO\033[1;32m.\033[1;33m.\033[1;31m. \033[1;33m"
                        fun_apchon
                        echo -e "\e[1DOk"
                        sleep 2
                        continue
                    }
                    ;;
                4)
                    if grep "duplicate-cn" /etc/SSHPlus/openvpn/server.conf >/dev/null 2>&1; then
                        clear
                        fun_multon() {
                            sed -i '/duplicate-cn/d' /etc/SSHPlus/openvpn/server.conf
                            sleep 1.5s
                            systemctl restart openvpn-server@server.service >/dev/null 2>&1
                        }
                        echo ""
                        echo -ne "\033[1;31mBLOQUEANDO MULTILOGIN\033[1;32m.\033[1;33m.\033[1;31m. \033[1;33m"
                        fun_multon
                        echo -e "\e[1DOk"
                        sleep 1
                        continue
                    else
                        clear
                        fun_multoff() {
                            grep -v "^duplicate-cn" /etc/SSHPlus/openvpn/server.conf > /tmp/tmpass && mv /tmp/tmpass /etc/SSHPlus/openvpn/server.conf
                            echo "duplicate-cn" >> /etc/SSHPlus/openvpn/server.conf
                            sleep 1.5s
                            systemctl restart openvpn-server@server.service >/dev/null 2>&1
                        }
                        echo ""
                        echo -ne "\033[1;32mPERMITINDO MULTILOGIN\033[1;32m.\033[1;33m.\033[1;31m. \033[1;33m"
                        fun_multoff
                        echo -e "\e[1DOk"
                        sleep 1
                        continue
                    fi
                    ;;
                5)
                    clear
                    echo -e "\E[44;1;37m         ALTERAR HOST DNS          \E[0m"
                    echo ""
                    echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mADICIONAR HOST DNS"
                    echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mREMOVER HOST DNS"
                    echo -e "\033[1;31m[\033[1;36m3\033[1;31m] \033[1;37m• \033[1;33mEDITAR MANUALMENTE"
                    echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR"
                    echo ""
                    echo -ne "\033[1;32mO QUE DESEJA FAZER \033[1;33m?\033[1;31m?\033[1;37m "
                    read resp
                    [[ -z "$resp" ]] && {
                        echo ""
                        echo -e "\033[1;31mOpção inválida!\033[0m"
                        sleep 2
                        continue
                    }
                    if [[ "$resp" = '1' ]]; then
                        clear
                        echo -e "\E[44;1;37m         Adicionar Host DNS          \E[0m"
                        echo ""
                        echo -e "\033[1;33mLista dos hosts atuais:\033[0m"
                        echo ""
                        for _host in $(grep -w "127.0.0.1" /etc/hosts | grep -v "localhost" | cut -d' ' -f2); do
                            echo -e "\033[1;32m$_host"
                        done
                        echo ""
                        echo -ne "\033[1;33mDigite o host a ser adicionado\033[1;37m : \033[0m"
                        read host
                        if [[ -z "$host" ]]; then
                            echo ""
                            echo -e "\033[1;31mCampo vazio ou inválido!\033[0m"
                            sleep 2
                            continue
                        fi
                        if [[ "$(grep -w "$host" /etc/hosts | wc -l)" -gt "0" ]]; then
                            echo -e "\033[1;31mEsse host já está adicionado!\033[0m"
                            sleep 2
                            continue
                        fi
                        sed -i "3i127.0.0.1 $host" /etc/hosts
                        echo ""
                        echo -e "\033[1;32mHost adicionado com sucesso!\033[0m"
                        sleep 2
                        continue
                    elif [[ "$resp" = '2' ]]; then
                        clear
                        echo -e "\E[44;1;37m         Remover Host DNS          \E[0m"
                        echo ""
                        echo -e "\033[1;33mLista dos hosts atuais:\033[0m"
                        echo ""
                        i=0
                        oP=""
                        for _host in $(grep -w "127.0.0.1" /etc/hosts | grep -v "localhost" | cut -d' ' -f2); do
                            i=$((i + 1))
                            printf -v formatted_i "%02d" $i
                            oP+="$formatted_i:$_host\n"
                            echo -e "\033[1;33m[\033[1;31m$formatted_i\033[1;33m] \033[1;37m- \033[1;32m$_host\033[0m"
                        done
                        echo ""
                        echo -ne "\033[1;32mSelecione o host a ser removido \033[1;33m[\033[1;37m1-$i\033[1;33m]\033[0m: "
                        read option
                        if [[ -z "$option" ]]; then
                            echo ""
                            echo -e "\033[1;31mOpção inválida!\033[0m"
                            sleep 2
                            continue
                        fi
                        if [[ "$option" =~ ^[0-9]+$ && "$option" -ge 1 && "$option" -le "$i" ]]; then
                            host=$(echo -e "$oP" | grep "^$(printf "%02d" $option):" | cut -d: -f2)
                            hst=$(grep -v "127.0.0.1 $host" /etc/hosts)
                            echo "$hst" > /etc/hosts
                            echo ""
                            echo -e "\033[1;32mHost removido com sucesso!\033[0m"
                            sleep 2
                            continue
                        else
                            echo ""
                            echo -e "\033[1;31mOpção inválida!\033[0m"
                            sleep 2
                            continue
                        fi
                    elif [[ "$resp" = '3' ]]; then
                        echo -e "\n\033[1;32mALTERANDO ARQUIVO \033[1;37m/etc/hosts\033[0m"
                        echo -e "\n\033[1;31mATENÇÃO!\033[0m"
                        echo -e "\n\033[1;33mPARA SALVAR USE AS TECLAS \033[1;32mctrl x y\033[0m"
                        sleep 3
                        clear
                        nano /etc/hosts
                        echo -e "\n\033[1;32mALTERADO COM SUCESSO!\033[0m"
                        sleep 2
                        continue
                    elif [[ "$resp" = '0' ]]; then
                        echo ""
                        echo -e "\033[1;31mRetornando...\033[0m"
                        sleep 2
                        exit 0
                    else
                        echo ""
                        echo -e "\033[1;31mOpção inválida!\033[0m"
                        sleep 2
                        continue
                    fi
                    ;;
                0)
                    echo ""
                    echo -e "\033[1;31mRetornando...\033[0m"
                    sleep 2
                    exit 0
                    ;;
                *)
                    echo ""
                    echo -e "\033[1;31mOpção inválida!\033[0m"
                    sleep 2
                    continue
                    ;;
            esac
        done
    else
        clear
        echo -e "\E[44;1;37m           INSTALADOR OPENVPN            \E[0m"
        echo ""
        echo -e "\033[1;33mRESPONDA AS QUESTÕES PARA INICIAR A INSTALAÇÃO"
        echo ""
        echo -ne "\033[1;32mPARA CONTINUAR CONFIRME SEU IP: \033[1;37m"
        read -e -i $IP IP
        [[ -z "$IP" ]] && {
            echo ""
            echo -e "\033[1;31mIP inválido!"
            sleep 3
            exit 1
        }
        echo ""
        read -p "$(echo -e "\033[1;32mQUAL PORTA DESEJA UTILIZAR? \033[1;37m")" -e -i 1194 porta
        [[ -z "$porta" ]] && {
            echo ""
            echo -e "\033[1;31mPorta inválida!"
            sleep 2
            exit 1
        }
        echo ""
        echo -e "\033[1;33mVERIFICANDO PORTA..."
        verif_ptrs $porta
        echo ""
        echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;33mSistema"
        echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;33mGoogle (\033[1;32mRecomendado\033[1;33m)"
        echo -e "\033[1;31m[\033[1;36m3\033[1;31m] \033[1;33mOpenDNS"
        echo -e "\033[1;31m[\033[1;36m4\033[1;31m] \033[1;33mCloudflare"
        echo -e "\033[1;31m[\033[1;36m5\033[1;31m] \033[1;33mHurricane Electric"
        echo -e "\033[1;31m[\033[1;36m6\033[1;31m] \033[1;33mVerisign"
        echo -e "\033[1;31m[\033[1;36m7\033[1;31m] \033[1;33mDNS Performace\033[0m"
        echo ""
        read -p "$(echo -e "\033[1;32mQUAL DNS DESEJA UTILIZAR? \033[1;37m")" -e -i 2 DNS
        echo ""
        echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;33mUDP"
        echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;33mTCP (\033[1;32mRecomendado\033[1;33m)"
        echo ""
        read -p "$(echo -e "\033[1;32mQUAL PROTOCOLO DESEJA UTILIZAR NO OPENVPN? \033[1;37m")" -e -i 2 resp
        if [[ "$resp" = '1' ]]; then
            PROTOCOL=udp
        elif [[ "$resp" = '2' ]]; then
            PROTOCOL=tcp
        else
            PROTOCOL=tcp
        fi
        echo ""
        [[ "$OS" = 'debian' ]] && {
            echo -e "\033[1;32mATUALIZANDO O SISTEMA"
            echo ""
            fun_bar "apt-get update -y" "Atualizando sistema"
            echo ""
            echo -e "\033[1;32mINSTALANDO DEPENDÊNCIAS"
            echo ""
            fun_bar "apt-get install openvpn iptables openssl ca-certificates zip openvpn-auth-pam -y" "Instalando dependências"
        } || {
            echo -e "\033[1;32mATUALIZANDO O SISTEMA"
            echo ""
            fun_bar "yum install epel-release -y" "Instalando repositório EPEL"
            echo ""
            echo -e "\033[1;32mINSTALANDO DEPENDÊNCIAS"
            echo ""
            fun_bar "yum install openvpn iptables openssl wget ca-certificates -y" "Instalando dependências"
        }
        echo ""
        echo -e "\033[1;32mINSTALANDO O OPENVPN  \033[1;31m(\033[1;33mPODE DEMORAR!\033[1;31m)"
        echo ""
        fun_dep
        fun_ropen() {
            [[ "$OS" = 'debian' ]] && {
                systemctl daemon-reload >/dev/null 2>&1
                systemctl restart openvpn-server@server.service >/tmp/openvpn.start.err 2>&1
                systemctl enable openvpn-server@server.service >/dev/null 2>&1
            } || {
                systemctl daemon-reload >/dev/null 2>&1
                systemctl restart openvpn@server.service >/tmp/openvpn.start.err 2>&1
                systemctl enable openvpn@server.service >/dev/null 2>&1
            }
            if ! systemctl is-active --quiet openvpn-server@server.service; then
                echo -e "\033[1;31mFalha ao iniciar o serviço OpenVPN!\033[0m"
                echo -e "\033[1;31mErro: $(cat /tmp/openvpn.start.err)\033[0m"
                journalctl -u openvpn-server@server.service -n 50
                exit 1
            fi
        }
        echo ""
        echo -e "\033[1;32mREINICIANDO O OPENVPN"
        echo ""
        fun_ropen
        IP2=$(wget -4qO- "http://whatismyip.akamai.com/" 2>/dev/null)
        if [[ -n "$IP2" && "$IP" != "$IP2" ]]; then
            IP="$IP2"
        fi
        cat <<-EOF >/etc/SSHPlus/openvpn/client-common.txt
client
dev tun
proto $PROTOCOL
sndbuf 0
rcvbuf 0
remote $IP $porta
resolv-retry 5
nobind
persist-key
persist-tun
remote-cert-tls server
cipher AES-256-GCM
verb 3
auth-user-pass
keepalive 10 120
float
EOF
        newclient "SSHPLUS"
        [[ $(netstat -nplt | grep -wc 'openvpn') != '0' ]] && echo -e "\n\033[1;32mOPENVPN INSTALADO COM SUCESSO\033[0m" || {
            echo -e "\n\033[1;31mERRO! A INSTALAÇÃO CORROMPEU\033[0m"
            echo -e "\033[1;31mLogs do serviço:\033[0m"
            journalctl -u openvpn-server@server.service -n 50
            exit 1
        }
        sleep 2
        exit 0
    fi
}
fun_conexao

	fun_socks() {
		clear
		echo -e "\033[01;31m┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\033[0m"
		echo -e "\033[01;31m┃\033[0m\033[44;1;37m         ★  WEB SOCKS  ★         \033[0m\033[01;31m┃\033[0m"
		echo -e "\033[01;31m┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫\033[0m"
		[[ $(netstat -nplt | grep -wc 'python') != '0' ]] && {
			sks='\033[1;32m◉'
			echo -e "\033[0;34m╼ \033[1;32mPORTAS\033[1;37m: \033[1;37m$(netstat -nplt | grep 'python' | awk {'print $4'} | cut -d: -f2 | xargs)"
		} || {
			sks='\033[1;31m○'
		}
		[[ $(screen -list | grep -wc 'proxy') != '0' ]] && var_sks1="\033[1;32m◉" || var_sks1="\033[1;31m○"
		[[ $(screen -list | grep -wc 'ws') != '0' ]] && var_sks2="\033[1;32m◉" || var_sks2="\033[1;31m○"
		[[ $(screen -list | grep -wc 'novoWS') != '0' ]] && var_sks3="\033[1;32m◉" || var_sks3="\033[1;31m○"
		[[ $(screen -list | grep -wc 'security') != '0' ]] && var_sks4="\033[1;32m◉" || var_sks4="\033[1;31m○"
		[[ "$(systemctl list-units --type=service --all | grep -c 'dragonx_port_')" != '0' ]] && var_sks5="\033[1;32m◉" || var_sks5="\033[1;31m○"
		[[ $(screen -list | grep -wc 'proxydt') != '0' ]] && var_sks6="\033[1;32m◉" || var_sks6="\033[1;31m○"
		[[ $(screen -list | grep -wc 'openpy') != '0' ]] && sksop="\033[1;32m◉" || sksop="\033[1;31m○"
		echo -e "\033[01;31m┃\033[0m\033[1;31m[\033[1;36m01\033[1;31m] \033[1;37m• \033[1;33mPROXY SOCKS SSH $var_sks1 \033[0m        \033[01;31m┃\033[0m"
		echo -e "\033[01;31m┃\033[0m\033[1;31m[\033[1;36m02\033[1;31m] \033[1;37m• \033[1;33mWEBSOCKET $var_sks2 \033[0m              \033[01;31m┃\033[0m"
		echo -e "\033[01;31m┃\033[0m\033[1;31m[\033[1;36m03\033[1;31m] \033[1;37m• \033[1;33mWEBSOCKET SECURITY $var_sks3 \033[0m     \033[01;31m┃\033[0m"
		echo -e "\033[01;31m┃\033[0m\033[1;31m[\033[1;36m04\033[1;31m] \033[1;37m• \033[1;33mWEBSOCKET SECURITY V2 $var_sks4 \033[0m  \033[01;31m┃\033[0m"
		echo -e "\033[01;31m┃\033[0m\033[1;31m[\033[1;36m05\033[1;31m] \033[1;37m• \033[1;33mPROXY DRAGON 2025 $var_sks5    \033[0m   \033[01;31m┃\033[0m"
		echo -e "\033[01;31m┃\033[0m\033[1;31m[\033[1;36m06\033[1;31m] \033[1;37m• \033[1;33mPROXY DTUNNEL MOD $var_sks6    \033[0m   \033[01;31m┃\033[0m"
		echo -e "\033[01;31m┃\033[0m\033[1;31m[\033[1;36m07\033[1;31m] \033[1;37m• \033[1;33mSOCKS OPENVPN $sksop \033[0m          \033[01;31m┃\033[0m"
		echo -e "\033[01;31m┃\033[0m\033[1;31m[\033[1;36m08\033[1;31m] \033[1;37m• \033[1;33mABRIR PORTA\033[0m               \033[01;31m┃\033[0m"
		echo -e "\033[01;31m┃\033[0m\033[1;31m[\033[1;36m09\033[1;31m] \033[1;37m• \033[1;33mALTERAR STATUS SOCKS SSH\033[0m  \033[01;31m┃\033[0m"
		echo -e "\033[01;31m┃\033[0m\033[1;31m[\033[1;36m10\033[1;31m] \033[1;37m• \033[1;33mALTERAR STATUS WEBSOCKET\033[0m  \033[01;31m┃\033[0m"
		echo -e "\033[01;31m┃\033[0m\033[1;31m[\033[1;36m00\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m                    \033[01;31m┃\033[0m"
		echo -e "\033[01;31m┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\033[0m"
		read -p "$(echo -e "\033[1;31m┗━➤\033[1;32mESOLHA UMA OPÇÃO DESEJADA\033[1;33m\033[1;31m\033[1;37m: ")" resposta
		if [[ "$resposta" = '1' ]]; then
			if ps x | grep -w proxy.py | grep -v grep 1>/dev/null 2>/dev/null; then
				clear
				echo -e "\E[41;1;37m             PROXY SOCKS              \E[0m"
				echo ""
				fun_socksoff() {
					for pidproxy in $(screen -ls | grep ".proxy" | awk {'print $1'}); do
						screen -r -S "$pidproxy" -X quit
					done
					[[ $(grep -wc "proxy.py" /etc/autostart) != '0' ]] && {
						sed -i '/proxy.py/d' /etc/autostart
					}
					sleep 1
					screen -wipe >/dev/null
				}
				echo -e "\033[1;32mDESATIVANDO O PROXY SOCKS\033[1;33m"
				echo ""
				fun_bar 'fun_socksoff'
				echo ""
				echo -e "\033[1;32mPROXY SOCKS DESATIVADO COM SUCESSO!\033[1;33m"
				sleep 3
				fun_socks
			else
				clear
				echo -e "\E[44;1;37m             PROXY SOCKS              \E[0m"
				echo ""
				echo -ne "\033[1;32mQUAL PORTA DESEJA ULTILIZAR \033[1;33m?\033[1;37m: "
				read porta
				[[ -z "$porta" ]] && {
					echo ""
					echo -e "\033[1;31mPorta invalida!"
					sleep 3
					clear
					fun_conexao
				}
				verif_ptrs $porta
				fun_inisocks() {
					sleep 1
					screen -dmS proxy python3 /etc/SSHPlus/proxy.py $porta
					[[ $(grep -wc "proxy.py" /etc/autostart) = '0' ]] && {
						echo -e "netstat -tlpn | grep -w $porta > /dev/null || {  screen -r -S 'proxy' -X quit;  screen -dmS proxy python3 /etc/SSHPlus/proxy.py $porta; }" >>/etc/autostart
					} || {
						sed -i '/proxy.py/d' /etc/autostart
						echo -e "netstat -tlpn | grep -w $porta > /dev/null || {  screen -r -S 'proxy' -X quit;  screen -dmS proxy python3 /etc/SSHPlus/proxy.py $porta; }" >>/etc/autostart
					}
				}
				echo ""
				echo -e "\033[1;32mINICIANDO O PROXY SOCKS\033[1;33m"
				echo ""
				fun_bar 'fun_inisocks'
				echo ""
				echo -e "\033[1;32mSOCKS ATIVADO COM SUCESSO\033[1;33m"
				sleep 3
				fun_socks
			fi
		elif [[ "$resposta" = '2' ]]; then
			if ps x | grep -w wsproxy.py | grep -v grep 1>/dev/null 2>/dev/null; then
				clear
				echo -e "\E[41;1;37m             WEBSOCKET              \E[0m"
				echo ""
				fun_wssocksoff() {
					for pidproxy in $(screen -ls | grep ".ws" | awk {'print $1'}); do
						screen -r -S "$pidproxy" -X quit
					done
					[[ $(grep -wc "wsproxy.py" /etc/autostart) != '0' ]] && {
						sed -i '/wsproxy.py/d' /etc/autostart
					}
					sleep 1
					screen -wipe >/dev/null
				}
				echo -e "\033[1;32mDESATIVANDO O WEBSOCKET\033[1;33m"
				echo ""
				fun_bar 'fun_wssocksoff'
				echo ""
				echo -e "\033[1;32mWEBSOCKET DESATIVADO COM SUCESSO!\033[1;33m"
				sleep 3
				fun_socks
			else
				clear
				echo -e "\E[44;1;37m             WEBSOCKET              \E[0m"
				echo ""
				echo -ne "\033[1;32mQUAL PORTA DESEJA ULTILIZAR \033[1;33m?\033[1;37m: "
				read porta
				[[ -z "$porta" ]] && {
					echo ""
					echo -e "\033[1;31mPorta invalida!"
					sleep 3
					clear
					fun_conexao
				}
				verif_ptrs $porta
				fun_iniwssocks() {
					sleep 1
					screen -dmS ws python3 /etc/SSHPlus/wsproxy.py $porta
					[[ $(grep -wc "wsproxy.py" /etc/autostart) = '0' ]] && {
						echo -e "netstat -tlpn | grep -w $porta > /dev/null || {  screen -r -S 'ws' -X quit;  screen -dmS ws python3 /etc/SSHPlus/wsproxy.py $porta; }" >>/etc/autostart
					} || {
						sed -i '/wsproxy.py/d' /etc/autostart
						echo -e "netstat -tlpn | grep -w $porta > /dev/null || {  screen -r -S 'ws' -X quit;  screen -dmS ws python3 /etc/SSHPlus/wsproxy.py $porta; }" >>/etc/autostart
					}
				}
				echo ""
				echo -e "\033[1;32mINICIANDO O WEBSOCKET\033[1;33m"
				echo ""
				fun_bar 'fun_iniwssocks'
				echo ""
				echo -e "\033[1;32WSSOCKS ATIVADO COM SUCESSO\033[1;33m"
				sleep 3
				fun_socks
			fi

elif [[ "$resposta" = '3' ]]; then
		clear
		if ps x | grep -w WebSocket | grep -v grep 1>/dev/null 2>/dev/null; then
		echo -e "\E[41;1;37m         WEBSOCKET SECURITY              \E[0m"
				echo ""
				fun_wsswsocksoff() { 
					pkill WebSocket
					for pidproxy in $(screen -ls | grep ".ws" | awk {'print $1'}); do
						screen -r -S "$WebSocket" -X quit
					done
					[[ $(grep -wc "WebSocket" /etc/autostart) != '0' ]] && {
						sed -i '/WebSocket/d' /etc/autostart
					}
					sleep 1
					screen -wipe >/dev/null
				}
				echo -e "\033[1;32mDESATIVANDO O WEBSOCKET SECURITY\033[1;33m"
				echo ""
				fun_bar 'fun_wsswsocksoff'
				echo ""
				echo -e "\033[1;32mWEBSOCKET SECURITY DESATIVADO COM SUCESSO!\033[1;33m"
				
				fun_socks
			else
		echo -e "\E[44;1;37m       🚀   WEBSOCKET SECURITY   🚀           \E[0m"
				echo ""
				rm -rf /etc/mamalista
				read -p "$(echo -e "★ \033[1;32mQUAL PORTA DESEJA ESCOLHER? \033[1;37m")" -e -i 80 cuzin
				echo "$cuzin" > /etc/mamalista
				echo ""
				read -p "$(echo -e "★ \033[1;32mBELEZA, QUAL MENSAGEM QUER? \033[1;37m")" -e -i WebSecurity cuzin2
				rm -rf /etc/mamalista2
				echo "$cuzin2" > /etc/mamalista2
				[[ -z "cuzin" ]] && {
					echo ""
					echo -e "\033[1;31mPorta invalida!"
					
				fun_socks
				}
				verif_ptrs $porta
				fun_iniwssocks() {
					sleep 1
					screen -dmS novoWS /etc/SSHPlus/WebSocket -proxy_port 0.0.0.0:$(cat /etc/mamalista) -msg="$(cat /etc/mamalista2) \033[01,33m"
					[[ $(grep -wc "WebSocket" /etc/autostart) = '0' ]] && {
						echo -e "screen -dmS novoWS /etc/SSHPlus/WebSocket -proxy_port 0.0.0.0:$(cat /etc/mamalista) -msg='$(cat /etc/mamalista2) \033[01,33m"
					} || {
						sed -i '/WebSocket/d' /etc/autostart
						echo -e "screen -dmS novoWS /etc/SSHPlus/WebSocket -proxy_port 0.0.0.0:$(cat /etc/mamalista) -msg='$(cat /etc/mamalista2) \033[01,33m"
					}
				}
				echo ""
				echo -e "\033[1;32mINICIANDO O WEBSOCKET SECURITY\033[1;33m"
				echo ""
				fun_bar 'fun_iniwssocks'
				echo ""
				echo -e "\033[1;32m WEBSOCKET SECURITY ATIVADO COM SUCESSO! ;)\033[1;33m"
				sleep 3
				fun_socks
			fi



elif [[ "$resposta" = '4' ]]; then
    clear
    if ps x | grep -w security | grep -v grep 1>/dev/null 2>/dev/null; then
        echo -e "\E[41;1;37m          WEBSOCKET SECURITY-V2.0         \E[0m"
        echo ""
        fun_securityoff() {
            for pidsecurity in $(screen -ls | grep ".security" | awk {'print $1'}); do
                screen -r -S "$pidsecurity" -X quit
            done
            [[ $(grep -wc "security" /etc/autostart) != '0' ]] && {
                sed -i '/security/d' /etc/autostart
            }
            sleep 1
            screen -wipe >/dev/null
        }
        echo -e "\033[1;32mDESATIVANDO O WEBSOCKET SECURITY\033[1;33m"
        echo ""
        fun_bar 'fun_securityoff'
        echo ""
        echo -e "\033[1;32mSECURITY DESATIVADO COM SUCESSO!\033[1;33m"
        
        fun_socks
    else
        echo -e "\E[44;1;37m          WEBSOCKET SECURITY         \E[0m"
        echo ""
        echo -e "\033[1;32mQUAL PORTA DESEJA ULTILIZAR ? \033"
        echo ""
        echo -e "\033[1;32mEXEMPLO :\033[1;33m80 ou 8080\033"
        echo ""
        read -p "$(echo -e "\033[1;32mQUAL PORTA DESEJA UTILIZAR? \033[1;37m: ")" portaws
        [[ -z "$portaws" ]] && {
            echo ""
            echo -e "\033[1;31mPorta invalida!"
            
            fun_socks
        }
        verif_ptrs $portaws
        fun_inisecurity() {
            sleep 1
            screen -dmS security /etc/SSHPlus/security -proxy_port 0.0.0.0:$portaws -msg=SECURITY
            [[ $(grep -wc "security" /etc/autostart) = '0' ]] && {
                echo -e "netstat -tlpn | grep -w $portaws > /dev/null || {  screen -r -S 'security' -X quit;  screen -dmS security /etc/SSHPlus/security -proxy_port 0.0.0.0:$portaws -msg=SECURITY; }" >>/etc/autostart
            } || {
                sed -i '/security/d' /etc/autostart
                echo -e "netstat -tlpn | grep -w $portaws > /dev/null || {  screen -r -S 'security' -X quit;  screen -dmS security /etc/SSHPlus/security -proxy_port 0.0.0.0:$portaws -msg=SECURITY; }" >>/etc/autostart
            }
        }
        echo ""
        echo -e "\033[1;32mINICIANDO WEBSOCKET SECURITY\033[1;33m"
        echo ""
        fun_bar 'fun_inisecurity'
        echo ""
        echo -e "\033[1;32SECURITY ATIVADO COM SUCESSO\033[1;33m"
        
        fun_socks
    fi
						
			
elif [[ "$resposta" = '500' ]]; then
    clear

elif [[ "$resposta" = '5' ]]; then
    clear
    echo -e "\E[44;1;37m             DRAGONX PROXY               \E[0m"
    echo ""

    DRAGONX_DIR="$HOME/DragonX"
    LOG_DIR="$DRAGONX_DIR/logs"
    PORTS_FILE="$DRAGONX_DIR/ports.list"
    BIN_NAME="dragon_go-x86"

    # ===============================
    # FUNÇÃO DE INSTALAÇÃO
    # ===============================
    instalar_dragonx() {
        echo -e "\033[1;33m🔄 Iniciando instalação do DragonX Proxy...\033[0m"
        sleep 1

        mkdir -p "$DRAGONX_DIR" "$LOG_DIR" >/tmp/dragonx_install.log 2>&1

        if command -v apt >/dev/null 2>&1; then
            sudo apt update -y >>/tmp/dragonx_install.log 2>&1
            sudo apt install -y git unzip wget screen >>/tmp/dragonx_install.log 2>&1
        fi

        # Clona repositório
        rm -rf "$DRAGONX_DIR"
        git clone --depth 1 https://git.dr2.site/penguinehis/DragonX-SSH-Proxy "$DRAGONX_DIR" >>/tmp/dragonx_install.log 2>&1

        # Permissões e link simbólico
        chmod +x "$DRAGONX_DIR"/* >>/tmp/dragonx_install.log 2>&1
        sudo ln -sf "$DRAGONX_DIR/proxy.sh" /usr/local/bin/dragonx >>/tmp/dragonx_install.log 2>&1

        # Atualiza systemd
        sudo systemctl daemon-reload
        sudo systemctl reset-failed

        echo -e "\033[1;32m✅ Instalação concluída com sucesso!\033[0m"
        sleep 2
    }

    # ===============================
    # FUNÇÃO ATIVAR/DESATIVAR
    # ===============================
    fun_dragonx() {
        # Chama função original de ativar/desativar que você já tinha
        DRAGONX_CMD="/usr/local/bin/dragonx"

        fun_dragonxoff() {
            echo -e "\033[1;32mDESATIVANDO O DRAGONX PROXY\033[1;33m"
            for svc in $(systemctl list-units --type=service --state=running | grep 'dragonx_port_' | awk '{print $1}'); do
                sudo systemctl stop "$svc" >/tmp/dragonx_off.log 2>&1
                sudo systemctl disable "$svc" >/tmp/dragonx_off.log 2>&1
                sudo rm -f "/etc/systemd/system/$svc" >>/tmp/dragonx_off.log 2>&1
            done
            [[ -f "$PORTS_FILE" ]] && rm -f "$PORTS_FILE"
            [[ $(grep -wc "dragonx" /etc/autostart) != '0' ]] && sed -i '/dragonx/d' /etc/autostart
            sudo systemctl daemon-reload >>/tmp/dragonx_off.log 2>&1
            echo -e "\033[1;32mDRAGONX PROXY DESATIVADO COM SUCESSO!\033[0m"
            sleep 1
        }

        if systemctl list-units --type=service | grep -q 'dragonx_port_'; then
            fun_dragonxoff
        else
            echo -e "\033[1;32mQUAL PORTA DESEJA UTILIZAR?\033[0m"
            read -p "PORTA: " porta
            [[ -z "$porta" ]] && { echo -e "\033[1;31mPorta inválida!\033[0m"; sleep 2; return; }
            if ! [[ "$porta" =~ ^[0-9]+$ ]] || [ "$porta" -lt 1 ] || [ "$porta" -gt 65535 ]; then
                echo -e "\033[1;31mPorta inválida: $porta\033[0m"; sleep 2; return
            fi

            mkdir -p "$DRAGONX_DIR" "$LOG_DIR"

            if [ ! -f "$DRAGONX_DIR/$BIN_NAME" ]; then
                echo -e "\033[1;31mErro: binário $BIN_NAME não encontrado em $DRAGONX_DIR\033[0m"
                return
            fi

            SERVICE_NAME="dragonx_port_$porta.service"
            sudo tee /etc/systemd/system/$SERVICE_NAME >/dev/null <<EOF
[Unit]
Description=DragonX SSH Proxy (Port $porta)
After=network.target

[Service]
Type=simple
WorkingDirectory=$DRAGONX_DIR
ExecStart=$DRAGONX_DIR/$BIN_NAME -port :$porta
Restart=always
StandardOutput=file:$LOG_DIR/proxy_$porta.log
StandardError=file:$LOG_DIR/proxy_$porta.log

[Install]
WantedBy=multi-user.target
EOF

            sudo systemctl daemon-reload
            sudo systemctl enable $SERVICE_NAME
            sudo systemctl start $SERVICE_NAME

            [[ ! -f "$PORTS_FILE" ]] && touch "$PORTS_FILE"
            if ! grep -q "^$porta$" "$PORTS_FILE"; then
                echo "$porta" >> "$PORTS_FILE"
            fi

            if [[ $(grep -wc "dragonx" /etc/autostart) = '0' ]]; then
                echo "netstat -tlpn | grep -w $porta > /dev/null || { systemctl start $SERVICE_NAME; }" >>/etc/autostart
            fi

            echo -e "\033[1;32mDRAGONX PROXY ATIVADO COM SUCESSO NA PORTA: $porta\033[0m"
            sleep 2
        fi
    }

    # ===============================
    # CHECA INSTALAÇÃO
    # ===============================
    if [[ ! -d "$DRAGONX_DIR" ]] || [[ ! -f "$DRAGONX_DIR/$BIN_NAME" ]]; then
        instalar_dragonx
        # Retorna ao menu principal após instalação
        bash /etc/bin/conexao
    else
        # Já instalado, chama função de ativar/desativar
        fun_dragonx
    fi


elif [[ "$resposta" = '6' ]]; then
    clear
    if ps x | grep -w proxydt | grep -v grep 1>/dev/null 2>/dev/null; then
        echo -e "\E[41;1;37m             PROXY DT               \E[0m"
        echo ""
        fun_proxydtoff() {
            for pidproxy in $(screen -ls | grep ".proxydt" | awk {'print $1'}); do
                screen -r -S "$pidproxy" -X quit
            done
            [[ $(grep -wc "proxydt" /etc/autostart) != '0' ]] && {
                sed -i '/proxydt/d' /etc/autostart
            }
            sleep 1
            screen -wipe >/dev/null
        }
        echo -e "\033[1;32mDESATIVANDO O PROXY DT\033[1;33m"
        echo ""
        fun_bar 'fun_proxydtoff'
        echo ""
        echo -e "\033[1;32mPROXY DT DESATIVADO COM SUCESSO!\033[1;33m"
        
        fun_socks
    else
        echo -e "\E[44;1;37m             PROXY DT               \E[0m"
        echo ""
        echo -e "\033[1;32mQUAL PORTA DESEJA ULTILIZAR ? \033"
        echo ""
        echo -e "\033[1;32mEXEMPLO :\033[1;33m80 ou 8080\033"
        echo ""
        read -p "$(echo -e "\033[1;32mQUAL PORTA DESEJA UTILIZAR? \033[1;37m: ")" porta
        [[ -z "$porta" ]] && {
            echo ""
            echo -e "\033[1;31mPorta invalida!"
            
            fun_socks
        }
        verif_ptrs $porta
        fun_iniproxydt() {
            sleep 1
            screen -dmS proxydt /etc/SSHPlus/proxydt --port $porta --http --openvpn-port --response PROXYDT
            [[ $(grep -wc "proxydt" /etc/autostart) = '0' ]] && {
                echo -e "netstat -tlpn | grep -w $porta > /dev/null || {  screen -r -S 'proxydt' -X quit;  screen -dmS proxydt /etc/SSHPlus/proxydt --port $porta --http --openvpn-port --response PROXY; }" >>/etc/autostart
            } || {
                sed -i '/proxydt/d' /etc/autostart
                echo -e "netstat -tlpn | grep -w $porta > /dev/null || {  screen -r -S 'proxydt' -X quit;  screen -dmS proxydt /etc/SSHPlus/proxydt --port $porta --http --openvpn-port --response PROXY; }" >>/etc/autostart
            }
        }
        echo ""
        echo -e "\033[1;32mINICIANDO O PROXY DT\033[1;33m"
        echo ""
        fun_bar 'fun_iniproxydt'
        echo ""
        echo -e "\033[1;32PROXY DT ATIVADO COM SUCESSO\033[1;33m"
        
        fun_socks
    fi





elif [[ "$resposta" = '7' ]]; then
    if ps x | grep -w open.py | grep -v grep 1>/dev/null 2>/dev/null; then
        clear
        echo -e "\E[41;1;37m            SOCKS OPENVPN             \E[0m"
        echo ""
        fun_socksopenoff() {
            for pidproxy in $(screen -list | grep -w "openpy" | awk {'print $1'}); do
                screen -r -S "$pidproxy" -X quit
            done
            [[ $(grep -wc "open.py" /etc/autostart) != '0' ]] && {
                sed -i '/open.py/d' /etc/autostart
            }
            sleep 1
            screen -wipe >/dev/null
        }
        echo -e "\033[1;32mDESATIVANDO O SOCKS OPEN\033[1;33m"
        echo ""
        fun_bar 'fun_socksopenoff'
        echo ""
        echo -e "\033[1;32mSOCKS DESATIVADO COM SUCESSO!\033[1;33m"
        sleep 2
        fun_socks
    else
        clear
        echo -e "\E[41;1;37m            SOCKS OPENVPN             \E[0m"
        echo ""
        echo -ne "\033[1;32mQUAL PORTA DESEJA UTILIZAR \033[1;33m?\033[1;37m: "
        read porta
        [[ -z "$porta" ]] && {
            echo ""
            echo -e "\033[1;31mPorta inválida!"
            sleep 2
            clear
            fun_conexao
        }
        verif_ptrs $porta
        fun_inisocksop() {
            [[ "$(netstat -tlpn | grep 'openvpn' | wc -l)" != '0' ]] && {
                listoldop=$(grep -w 'DEFAULT_HOST =' /etc/SSHPlus/open.py | cut -d"'" -f2 | cut -d: -f2)
                listopen=$(netstat -tlpn | grep -w openvpn | grep -v 127.0.0.1 | awk {'print $4'} | cut -d: -f2)
                sed -i "s/$listoldop/$listopen/" /etc/SSHPlus/open.py
            }
            sleep 1
            screen -dmS openpy python3 /etc/SSHPlus/open.py $porta
            [[ $(grep -wc "open.py" /etc/autostart) = '0' ]] && {
                echo -e "netstat -tlpn | grep -w $porta > /dev/null || { screen -r -S 'openpy' -X quit; screen -dmS openpy python3 /etc/SSHPlus/open.py $porta; }" >>/etc/autostart
            } || {
                sed -i '/open.py/d' /etc/autostart
                echo -e "netstat -tlpn | grep -w $porta > /dev/null || { screen -r -S 'openpy' -X quit; screen -dmS openpy python3 /etc/SSHPlus/open.py $porta; }" >>/etc/autostart
            }
        }
        echo ""
        echo -e "\033[1;32mINICIANDO O SOCKS OPENVPN\033[1;33m"
        echo ""
        fun_bar 'fun_inisocksop'
        echo ""
        echo -e "\033[1;32mSOCKS OPENVPN ATIVADO COM SUCESSO\033[1;33m"
        sleep 3
        fun_socks
    fi
		elif [[ "$resposta" = '8' ]]; then
			if ps x | grep proxy.py | grep -v grep 1>/dev/null 2>/dev/null; then
				sockspt=$(netstat -nplt | grep 'python3' | awk {'print $4'} | cut -d: -f2 | xargs)
				clear
				echo -e "\E[44;1;37m            PROXY SOCKS             \E[0m"
				echo ""
				echo -e "\033[1;33mPORTAS EM USO: \033[1;32m$sockspt"
				echo ""
				echo -ne "\033[1;32mQUAL PORTA DESEJA ULTILIZAR \033[1;33m?\033[1;37m: "
				read porta
				[[ -z "$porta" ]] && {
					echo ""
					echo -e "\033[1;31mPorta invalida!"
					sleep 2
					clear
					fun_conexao
				}
				verif_ptrs $porta
				echo ""
				echo -e "\033[1;32mINICIANDO O PROXY SOCKS NA PORTA \033[1;31m$porta\033[1;33m"
				echo ""
				abrirptsks() {
					sleep 1
					screen -dmS proxy python3 /etc/SSHPlus/proxy.py $porta
					sleep 1
				}
				fun_bar 'abrirptsks'
				echo ""
				echo -e "\033[1;32mPROXY SOCKS ATIVADO COM SUCESSO\033[1;33m"
				sleep 2
				fun_socks
			else
				clear
				echo -e "\033[1;31mFUNCAO INDISPONIVEL\n\n\033[1;33mATIVE O SOCKS PRIMEIRO !\033[1;33m"
				sleep 2
				fun_socks
			fi
		elif [[ "$resposta" = '9' ]]; then
			if ps x | grep -w proxy.py | grep -v grep 1>/dev/null 2>/dev/null; then
				clear
				msgsocks=$(cat /etc/SSHPlus/proxy.py | grep -E "MSG =" | awk -F = '{print $2}' | cut -d "'" -f 2)
				echo -e "\E[44;1;37m             PROXY SOCKS              \E[0m"
				echo ""
				echo -e "\033[1;33mSTATUS: \033[1;32m$msgsocks"
				echo""
				echo -ne "\033[1;32mINFORME SEU STATUS\033[1;31m:\033[1;37m "
				read msgg
				[[ -z "$msgg" ]] && {
					echo -e "\n\033[1;31mStatus invalido!"
					sleep 2
					fun_conexao
				}
				[[ ${msgg} != ?(+|-)+([a-zA-Z0-9-. ]) ]] && {
					echo -e "\n\033[1;31m[\033[1;33m!\033[1;31m]\033[1;33m EVITE CARACTERES ESPECIAIS\033[0m"
					sleep 2
					fun_socks
				}
				echo -e "\n\033[1;31m[\033[1;36m01\033[1;31m]\033[1;33m AZUL"
				echo -e "\033[1;31m[\033[1;36m02\033[1;31m]\033[1;33m VERDE"
				echo -e "\033[1;31m[\033[1;36m03\033[1;31m]\033[1;33m VERMELHO"
				echo -e "\033[1;31m[\033[1;36m04\033[1;31m]\033[1;33m AMARELO"
				echo -e "\033[1;31m[\033[1;36m05\033[1;31m]\033[1;33m ROSA"
				echo -e "\033[1;31m[\033[1;36m06\033[1;31m]\033[1;33m CYANO"
				echo -e "\033[1;31m[\033[1;36m07\033[1;31m]\033[1;33m LARANJA"
				echo -e "\033[1;31m[\033[1;36m08\033[1;31m]\033[1;33m ROXO"
				echo -e "\033[1;31m[\033[1;36m09\033[1;31m]\033[1;33m PRETO"
				echo -e "\033[1;31m[\033[1;36m10\033[1;31m]\033[1;33m SEM COR"
				echo ""
				echo -ne "\033[1;32mQUAL A COR\033[1;31m ?\033[1;37m : "
				read sts_cor
				if [[ "$sts_cor" = "1" ]] || [[ "$sts_cor" = "01" ]]; then
					cor_sts='blue'
				elif [[ "$sts_cor" = "2" ]] || [[ "$sts_cor" = "02" ]]; then
					cor_sts='green'
				elif [[ "$sts_cor" = "3" ]] || [[ "$sts_cor" = "03" ]]; then
					cor_sts='red'
				elif [[ "$sts_cor" = "4" ]] || [[ "$sts_cor" = "04" ]]; then
					cor_sts='yellow'
				elif [[ "$sts_cor" = "5" ]] || [[ "$sts_cor" = "05" ]]; then
					cor_sts='#F535AA'
				elif [[ "$sts_cor" = "6" ]] || [[ "$sts_cor" = "06" ]]; then
					cor_sts='cyan'
				elif [[ "$sts_cor" = "7" ]] || [[ "$sts_cor" = "07" ]]; then
					cor_sts='#FF7F00'
				elif [[ "$sts_cor" = "8" ]] || [[ "$sts_cor" = "08" ]]; then
					cor_sts='#9932CD'
				elif [[ "$sts_cor" = "9" ]] || [[ "$sts_cor" = "09" ]]; then
					cor_sts='black'
				elif [[ "$sts_cor" = "10" ]]; then
					cor_sts='null'
				else
					echo -e "\n\033[1;33mOPCAO INVALIDA !"
					cor_sts='null'
				fi
				fun_msgsocks() {
					msgsocks2=$(cat /etc/SSHPlus/proxy.py | grep "MSG =" | awk -F = '{print $2}')
					sed -i "s/$msgsocks2/ '$msgg'/g" /etc/SSHPlus/proxy.py
					sleep 1
					cor_old=$(grep 'color=' /etc/SSHPlus/proxy.py | cut -d '"' -f2)
					sed -i "s/\b$cor_old\b/$cor_sts/g" /etc/SSHPlus/proxy.py
				}
				echo ""
				echo -e "\033[1;32mALTERANDO STATUS!"
				echo ""
				fun_bar 'fun_msgsocks'
				restartsocks() {
					if ps x | grep proxy.py | grep -v grep 1>/dev/null 2>/dev/null; then
						echo -e "$(netstat -nplt | grep 'python3' | awk {'print $4'} | cut -d: -f2 | xargs)" >/tmp/Pt_sks
						for pidproxy in $(screen -ls | grep ".proxy" | awk {'print $1'}); do
							screen -r -S "$pidproxy" -X quit
						done
						screen -wipe >/dev/null
						_Ptsks="$(cat /tmp/Pt_sks)"
						sleep 1
						screen -dmS proxy python3 /etc/SSHPlus/proxy.py $_Ptsks
						rm /tmp/Pt_sks
					fi
                }
				echo ""
				echo -e "\033[1;32mREINICIANDO PROXY SOCKS!"
				echo ""
				fun_bar 'restartsocks'
				echo ""
				echo -e "\033[1;32mSTATUS ALTERADO COM SUCESSO!"
				sleep 2
				fun_socks
			else
				clear
				echo -e "\033[1;31mFUNCAO INDISPONIVEL\n\n\033[1;33mATIVE O SOCKS SSH PRIMEIRO !\033[1;33m"
				sleep 2
				fun_socks
			fi
        		elif [[ "$resposta" = '10' ]]; then
			if ps x | grep -w wsproxy.py | grep -v grep 1>/dev/null 2>/dev/null; then
				clear
				msgsocks=$(cat /etc/SSHPlus/wsproxy.py | grep -E "MSG =" | awk -F = '{print $2}' | cut -d "'" -f 2)
				echo -e "\E[44;1;37m             WEBSOCKET              \E[0m"
				echo ""
				echo -e "\033[1;33mSTATUS: \033[1;32m$msgsocks"
				echo""
				echo -ne "\033[1;32mINFORME SEU STATUS\033[1;31m:\033[1;37m "
				read msgg
				[[ -z "$msgg" ]] && {
					echo -e "\n\033[1;31mStatus invalido!"
					sleep 2
					fun_conexao
				}
				[[ ${msgg} != ?(+|-)+([a-zA-Z0-9-. ]) ]] && {
					echo -e "\n\033[1;31m[\033[1;33m!\033[1;31m]\033[1;33m EVITE CARACTERES ESPECIAIS\033[0m"
					sleep 2
					fun_socks
				}
				echo -e "\n\033[1;31m[\033[1;36m01\033[1;31m]\033[1;33m AZUL"
				echo -e "\033[1;31m[\033[1;36m02\033[1;31m]\033[1;33m VERDE"
				echo -e "\033[1;31m[\033[1;36m03\033[1;31m]\033[1;33m VERMELHO"
				echo -e "\033[1;31m[\033[1;36m04\033[1;31m]\033[1;33m AMARELO"
				echo -e "\033[1;31m[\033[1;36m05\033[1;31m]\033[1;33m ROSA"
				echo -e "\033[1;31m[\033[1;36m06\033[1;31m]\033[1;33m CYANO"
				echo -e "\033[1;31m[\033[1;36m07\033[1;31m]\033[1;33m LARANJA"
				echo -e "\033[1;31m[\033[1;36m08\033[1;31m]\033[1;33m ROXO"
				echo -e "\033[1;31m[\033[1;36m09\033[1;31m]\033[1;33m PRETO"
				echo -e "\033[1;31m[\033[1;36m10\033[1;31m]\033[1;33m SEM COR"
				echo ""
				echo -ne "\033[1;32mQUAL A COR\033[1;31m ?\033[1;37m : "
				read sts_cor
				if [[ "$sts_cor" = "1" ]] || [[ "$sts_cor" = "01" ]]; then
					cor_sts='blue'
				elif [[ "$sts_cor" = "2" ]] || [[ "$sts_cor" = "02" ]]; then
					cor_sts='green'
				elif [[ "$sts_cor" = "3" ]] || [[ "$sts_cor" = "03" ]]; then
					cor_sts='red'
				elif [[ "$sts_cor" = "4" ]] || [[ "$sts_cor" = "04" ]]; then
					cor_sts='yellow'
				elif [[ "$sts_cor" = "5" ]] || [[ "$sts_cor" = "05" ]]; then
					cor_sts='#F535AA'
				elif [[ "$sts_cor" = "6" ]] || [[ "$sts_cor" = "06" ]]; then
					cor_sts='cyan'
				elif [[ "$sts_cor" = "7" ]] || [[ "$sts_cor" = "07" ]]; then
					cor_sts='#FF7F00'
				elif [[ "$sts_cor" = "8" ]] || [[ "$sts_cor" = "08" ]]; then
					cor_sts='#9932CD'
				elif [[ "$sts_cor" = "9" ]] || [[ "$sts_cor" = "09" ]]; then
					cor_sts='black'
				elif [[ "$sts_cor" = "10" ]]; then
					cor_sts='null'
				else
					echo -e "\n\033[1;33mOPCAO INVALIDA !"
					cor_sts='null'
				fi
				fun_msgsocks() {
					msgsocks2=$(cat /etc/SSHPlus/wsproxy.py | grep "MSG =" | awk -F = '{print $2}')
					sed -i "s/$msgsocks2/ '$msgg'/g" /etc/SSHPlus/wsproxy.py
					sleep 1
					cor_old=$(grep 'color=' /etc/SSHPlus/wsproxy.py | cut -d '"' -f2)
					sed -i "s/\b$cor_old\b/$cor_sts/g" /etc/SSHPlus/wsproxy.py
				}
				echo ""
				echo -e "\033[1;32mALTERANDO STATUS!"
				echo ""
				fun_bar 'fun_msgsocks'
                restartwssocks() {
                    if ps x | grep wsproxy.py | grep -v grep 1>/dev/null 2>/dev/null; then
						echo -e "$(netstat -nplt | grep 'python3' | awk {'print $4'} | cut -d: -f2 | xargs)" >/tmp/Pt_wssks
						for pidproxy in $(screen -ls | grep ".ws" | awk {'print $1'}); do
							screen -r -S "$pidproxy" -X quit
						done
						screen -wipe >/dev/null
						_Ptwssks="$(cat /tmp/Pt_wssks)"
						sleep 1
						screen -dmS ws python3 /etc/SSHPlus/wsproxy.py $_Ptwssks
						rm /tmp/Pt_wssks
					fi
				}
				echo ""
				echo -e "\033[1;32mREINICIANDO WEBSOCKET!"
				echo ""
				fun_bar 'restartwssocks'
				echo ""
				echo -e "\033[1;32mSTATUS ALTERADO COM SUCESSO!"
				sleep 2
				fun_socks
			else
				clear
				echo -e "\033[1;31mFUNCAO INDISPONIVEL\n\n\033[1;33mATIVE O WEBSOCKET PRIMEIRO !\033[1;33m"
				sleep 2
				fun_socks
			fi
		elif [[ "$resposta" = '0' ]]; then
			echo ""
			echo -e "\033[1;31mRetornando...\033[0m"
			sleep 1
			fun_conexao
		else
			echo ""
			echo -e "\033[1;31mOpcao invalida !\033[0m"
			sleep 1
			fun_socks
		fi

	}

	fun_openssh() {
		clear
		echo -e "\E[44;1;37m            OPENSSH             \E[0m\n"
		echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mADICIONAR PORTA\033[1;31m
[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mREMOVER PORTA\033[1;31m
[\033[1;36m3\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m"
		echo ""
		echo -ne "\033[1;32mOQUE DESEJA FAZER \033[1;33m?\033[1;37m "
		read resp
		if [[ "$resp" = '1' ]]; then
			clear
			echo -e "\E[44;1;37m         ADICIONAR PORTA AO SSH         \E[0m\n"
			echo -ne "\033[1;32mQUAL PORTA DESEJA ADICIONAR \033[1;33m?\033[1;37m "
			read pt
			[[ -z "$pt" ]] && {
				echo -e "\n\033[1;31mPorta invalida!"
				sleep 3
				fun_conexao
			}
			verif_ptrs $pt
			echo -e "\n\033[1;32mADICIONANDO PORTA AO SSH\033[0m"
			echo ""
			fun_addpssh() {
				echo "Port $pt" >>/etc/ssh/sshd_config
				service ssh restart
			}
			fun_bar 'fun_addpssh'
			echo -e "\n\033[1;32mPORTA ADICIONADA COM SUCESSO\033[0m"
			sleep 3
			fun_conexao
		elif [[ "$resp" = '2' ]]; then
			clear
			echo -e "\E[41;1;37m         REMOVER PORTA DO SSH         \E[0m"
			echo -e "\n\033[1;33m[\033[1;31m!\033[1;33m] \033[1;32mPORTA PADRAO \033[1;37m22 \033[1;33mCUIDADO !\033[0m"
			echo -e "\n\033[1;33mPORTAS EM USO: \033[1;37m$(grep 'Port' /etc/ssh/sshd_config | cut -d' ' -f2 | grep -v 'no' | xargs)\n"
			echo -ne "\033[1;32mQUAL PORTA DESEJA REMOVER \033[1;33m?\033[1;37m "
			read pt
			[[ -z "$pt" ]] && {
				echo -e "\n\033[1;31mPorta invalida!"
				sleep 2
				fun_conexao
			}
			[[ $(grep -wc "$pt" '/etc/ssh/sshd_config') != '0' ]] && {
				echo -e "\n\033[1;32mREMOVENDO PORTA DO SSH\033[0m"
				echo ""
				fun_delpssh() {
					sed -i "/Port $pt/d" /etc/ssh/sshd_config
					service ssh restart
				}
				fun_bar 'fun_delpssh'
				echo -e "\n\033[1;32mPORTA REMOVIDA COM SUCESSO\033[0m"
				sleep 2
				fun_conexao
			} || {
				echo -e "\n\033[1;31mPorta invalida!"
				sleep 2
				fun_conexao
			}
		elif [[ "$resp" = '3' ]]; then
			echo -e "\n\033[1;31mRetornando.."
			sleep 2
			fun_conexao
		else
			echo -e "\n\033[1;31mOpcao invalida!"
			sleep 2
			fun_conexao
		fi
	}

	fun_sslh() {
		[[ "$(netstat -nltp | grep 'sslh' | wc -l)" = '0' ]] && {
			clear
			echo -e "\E[44;1;37m             INSTALADOR SSLH               \E[0m\n"
			echo -e "\n\033[1;33m[\033[1;31m!\033[1;33m] \033[1;32mA PORTA \033[1;37m443 \033[1;32mSERA USADA POR PADRAO\033[0m\n"
			echo -ne "\033[1;32mREALMENTE DESEJA INSTALAR O SSLH \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read resp
			[[ "$resp" = 's' ]] && {
				verif_ptrs 443
				fun_instsslh() {
					[[ -e "/etc/stunnel/stunnel.conf" ]] && ptssl="$(netstat -nplt | grep 'stunnel' | awk {'print $4'} | cut -d: -f2 | xargs)" || ptssl='3128'
					[[ -e "/etc/openvpn/server.conf" ]] && ptvpn="$(netstat -nplt | grep 'openvpn' | awk {'print $4'} | cut -d: -f2 | xargs)" || ptvpn='1194'
					DEBIAN_FRONTEND=noninteractive apt-get -y install sslh
					echo -e "#Modo autónomo\n\nRUN=yes\n\nDAEMON=/usr/sbin/sslh\n\nDAEMON_OPTS='--user sslh --listen 0.0.0.0:443 --ssh 127.0.0.1:22 --ssl 127.0.0.1:$ptssl --http 127.0.0.1:80 --openvpn 127.0.0.1:$ptvpn --pidfile /var/run/sslh/sslh.pid'" >/etc/default/sslh
					/etc/init.d/sslh start && service sslh start
				}
				echo -e "\n\033[1;32mINSTALANDO O SSLH !\033[0m\n"
				fun_bar 'fun_instsslh'
				echo -e "\n\033[1;32mINICIANDO O SSLH !\033[0m\n"
				fun_bar '/etc/init.d/sslh restart && service sslh restart'
				[[ $(netstat -nplt | grep -w 'sslh' | wc -l) != '0' ]] && echo -e "\n\033[1;32mINSTALADO COM SUCESSO !\033[0m" || echo -e "\n\033[1;31mERRO INESPERADO !\033[0m"
				sleep 3
				fun_conexao
			} || {
				echo -e "\n\033[1;31mRetornando.."
				sleep 2
				fun_conexao
			}
		} || {
			clear
			echo -e "\E[41;1;37m             REMOVER O SSLH               \E[0m\n"
			echo -ne "\033[1;32mREALMENTE DESEJA REMOVER O SSLH \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read respo
			[[ "$respo" = "s" ]] && {
				fun_delsslh() {
					/etc/init.d/sslh stop && service sslh stop
					apt-get remove sslh -y
					apt-get purge sslh -y
				}
				echo -e "\n\033[1;32mREMOVENDO O SSLH !\033[0m\n"
				fun_bar 'fun_delsslh'
				echo -e "\n\033[1;32mREMOVIDO COM SUCESSO !\033[0m\n"
				sleep 2
				fun_conexao
			} || {
				echo -e "\n\033[1;31mRetornando.."
				sleep 2
				fun_conexao
			}
		}
	}

	fun_conexao() {
		while true; do
			clear
system=$(cat /etc/issue.net)
date=$(date '+%Y-%m-%d <> %H:%M:%S')
echo -e "\033[1;37m $system    $date"
echo -e "\033[01;31m┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\033[0m"
echo -e "\033[01;31m┃\033[1;31m\033[5;34;47m               💎 CONEXAO 💎               \033[1;33m \033[0m\033[01;31m┃"
echo -e "\033[01;31m┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\033[0m"
			echo -e "\033[01;31m┃\033[1;32mSERVICO: \033[1;33mOPENSSH \033[1;32mPORTA: \033[1;37m$(grep 'Port' /etc/ssh/sshd_config | cut -d' ' -f2 | grep -v 'no' | xargs)\033[01;31m                       \033[0m" && sts6="\033[1;32m◉ "
			[[ "$(ps x | grep 'slowdns' | grep -v 'grep'|wc -l)" != '0' ]] && {
				sts9="\033[1;32m◉ "
			} || {
				sts9="\033[1;31m○ "
			}            
			[[ "$(netstat -tlpn | grep 'sslh' | wc -l)" != '0' ]] && {
				echo -e "\033[01;31m┃\033[1;32mSERVICO: \033[1;33mSSLH: \033[1;32mPORTA: \033[1;37m$(netstat -nplt | grep 'sslh' | awk {'print $4'} | cut -d: -f2 | xargs)\033[01;31m                       \033[0m"
				sts7="\033[1;32m◉ "
			} || {
				sts7="\033[1;31m○ "
			}
			[[ "$(netstat -tlpn | grep 'openvpn' | wc -l)" != '0' ]] && {
				echo -e "\033[01;31m┃\033[1;32mSERVICO: \033[1;33mOPENVPN: \033[1;32mPORTA: \033[1;37m$(netstat -nplt | grep 'openvpn' | awk {'print $4'} | cut -d: -f2 | xargs)\033[01;31m                       \033[0m"
				sts10="\033[1;32m◉ "
			} || {
				sts10="\033[1;31m○ "
			}

			[[ "$(netstat -tlpn | grep 'WebSocket' | wc -l)" != '0' ]] && {
				echo -e "\033[01;31m┃\033[1;32mSERVICO: \033[1;33mWEBSOCKET SECURITY \033[1;32mPORTA: \033[1;37m"$(cat /etc/mamalista)"\033[01;31m                       \033[0m"
				sts4="\033[1;32m◉ "
			} || {
				sts4="\033[1;31m○ "
			}

            [[ "$(netstat -tlpn | grep 'security' | wc -l)" != '0' ]] && {
            	porta_security=$(netstat -nplt | grep -w 'security' | awk '{split($4,a,":"); print a[length(a)]}')
           	 	echo -e "\033[01;31m┃\033[1;32mSERVICO: \033[1;33mWEBSOCKET SECURITY V2.0 \033[1;32mPORTA: \033[1;37m$porta_security"
            	sts4="\033[1;32m◉ "
            } || {
            	sts4="\033[1;31m○ "
            }

			[[ "$(netstat -tlpn 2>/dev/null | grep -E '/proxy( |$)' | wc -l)" != '0' ]] && {
				echo -e "\033[01;31m┃\033[1;32mSERVICO: \033[1;33mMULTIPROXY \033[1;32mPORTA: \033[1;37m$(netstat -nplt 2>/dev/null | grep -E '/proxy( |$)' | awk '{print $4}' | awk -F ':' '{print $NF}' | xargs)"
				sts0="\033[1;32m◉ "
			} || {
				sts0="\033[1;31m○ "
			}
            [[ "$(netstat -tlpn | grep 'proxydt' | wc -l)" != '0' ]] && {
				echo -e "\033[01;31m┃\033[1;32mSERVICO: \033[1;33mPROXY DTUNNEL MOD \033[1;32mPORTA: \033[1;37m$(netstat -nplt | grep 'proxydt' | awk {'print $4'} | cut -d: -f2 | xargs)"
				sts4="\033[1;32m◉ "
			} || {
				sts4="\033[1;31m○ "
			}

			[[ "$(systemctl list-units --type=service --all | grep -c 'dragonx')" != '0' ]] && {
				echo -e "\033[01;31m┃\033[1;32mSERVICO: \033[1;33mDRAGONX PROXY\033[1;31m: \033[1;37m$(systemctl list-units --type=service --state=running | grep 'dragonx' | awk '{print $1}' | sed 's/[^0-9]//g' | xargs)"
				sts4="\033[1;32m◉ "
			} || {
				sts4="\033[1;31m○ "
			}

			[[ "$(netstat -tlpn | grep -E 'python3|proxydt|security' | wc -l)" != '0' ]] && {  
				echo -e "\033[01;31m┃\033[1;32mSERVICO: \033[1;33mPROXY SOCKS PORTAS ATIVADAS\033[1;31m: \033[1;37m$(netstat -nplt | grep -E 'python3|proxydt|security|dragonx' | awk '{print $4}' | cut -d: -f2 | xargs)"  
				sts4="\033[1;32m◉ "
			} || {
				sts4="\033[1;31m○ "
			}
			
			[[ -e "/etc/stunnel/stunnel.conf" ]] && {
				echo -e "\033[01;31m┃\033[1;32mSERVICO: \033[1;33mSSL STUNNEL4 \033[1;32mPORTA: \033[1;37m$(netstat -nplt | grep 'stunnel4' | awk {'print $4'} | cut -d: -f2 | xargs)\033[01;31m                       \033[0m"
				sts3="\033[1;32m◉ "
			} || {
				sts3="\033[1;31m○ "
			}

			[[ -e "/usr/local/etc/stunnel/stunnel.conf" ]] && {
				echo -e "\033[01;31m┃\033[1;32mSERVICO: \033[1;33mSSL STUNNEL5 \033[1;32mPORTA: \033[1;37m$(netstat -nplt | grep 'stunnel5' | awk {'print $4'} | cut -d: -f2 | xargs)\033[01;31m                       \033[0m"
				sts15="\033[1;32m◉ "
			} || {
				sts15="\033[1;31m○ "
			}

			[[ "$(netstat -tlpn | grep 'dropbear' | wc -l)" != '0' ]] && {
				echo -e "\033[01;31m\033[1;32mSERVICO: \033[1;33mDROPBEAR \033[1;32mPORTA: \033[1;37m$(netstat -nplt | grep 'dropbear' | awk -F ":" {'print $4'} | xargs)\033[01;31m                       \033[0m"
				sts2="\033[1;32m◉ "
			} || {
				sts2="\033[1;31m○ "
			}
                        [[ "$(netstat -tlpn | grep 'proxy10000000' | wc -l)" != '0' ]] && {
				echo -e "\033[01;31m┃\033[1;32mSERVICO: \033[1;33mPROXY DTUNNEL \033[1;32mPORTA: \033[1;37m$(netstat -nplt | grep 'proxy' | awk {'print $4'} | cut -d: -f2 | xargs)"
				sts110000="\033[1;32m◉ "
			} || {
				sts110000="\033[1;31m○ "
			}

			[[ "$(netstat -tunlp | grep 'v2ray' | wc -l)" != '0' ]] && {
				xv2ray="\033[1;32m◉ "
			} || {
				xv2ray="\033[1;31m○ "
			}
			[[ "$(netstat -tunlp | grep 'xray' | wc -l)" != '0' ]] && {
				xray="\033[1;32m◉ "
			} || {
				xray="\033[1;31m○ "
			}
			echo -e "\033[01;31m┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\033[0m"         
			echo -e "\033[01;31m┃\033[1;31m\033[1;34m[\033[1;37m 01 •\033[1;34m]\033[1;37m ➩  \033[1;33mOPENSSH $sts6\033[0;31m                       \033[01;31m┃"
echo -e "\033[01;31m┃\033[1;31m\033[1;34m[\033[1;37m 02 •\033[1;34m]\033[1;37m ➩  \033[1;33mDROPBEAR $sts2\033[0;31m                      \033[01;31m┃"
echo -e "\033[01;31m┃\033[1;31m\033[1;34m[\033[1;37m 03 •\033[1;34m]\033[1;37m ➩  \033[1;33mOPENVPN $sts10\033[0;31m                       \033[01;31m┃"
echo -e "\033[01;31m┃\033[1;31m\033[1;34m[\033[1;37m 04 •\033[1;34m]\033[1;37m ➩  \033[1;33mPROXY SOCKS $sts4\033[0;31m                   \033[01;31m┃"
echo -e "\033[01;31m┃\033[1;31m\033[1;34m[\033[1;37m 05 •\033[1;34m]\033[1;37m ➩  \033[1;33mMULTI PROXY $sts0\033[0;31m                   \033[01;31m┃"
echo -e "\033[01;31m┃\033[1;31m\033[1;34m[\033[1;37m 06 •\033[1;34m]\033[1;37m ➩  \033[1;33mSSL STUNNEL4  $sts3\033[0;31m                 \033[01;31m┃"
echo -e "\033[01;31m┃\033[1;31m\033[1;34m[\033[1;37m 07 •\033[1;34m]\033[1;37m ➩  \033[1;33mSSL STUNNEL5  $sts15\033[0;31m                 \033[01;31m┃"
echo -e "\033[01;31m┃\033[1;31m\033[1;34m[\033[1;37m 08 •\033[1;34m]\033[1;37m ➩  \033[1;33mSLOWDNS $sts9\033[0;31m                       \033[01;31m┃"
echo -e "\033[01;31m┃\033[1;31m\033[1;34m[\033[1;37m 09 •\033[1;34m]\033[1;37m ➩  \033[1;33mXRAY 2025 $xray\033[0;31m                     \033[01;31m┃"
echo -e "\033[01;31m┃\033[1;31m\033[1;34m[\033[1;37m 10 •\033[1;34m]\033[1;37m ➩  \033[1;33mV2RAY $xv2ray\033[0;31m                         \033[01;31m┃"
echo -e "\033[01;31m┃\033[1;31m\033[1;34m[\033[1;37m 11 •\033[1;34m]\033[1;37m ➩  \033[1;33mLIMPAR V2RAY \033[0;31m                    \033[01;31m┃"
echo -e "\033[01;31m┃\033[1;31m\033[1;34m[\033[1;37m 12 •\033[1;34m]\033[1;37m ➩  \033[1;33mVOLTAR  \033[1;32m<\033[1;33m<\033[1;31m< \033[0;31m                     \033[01;31m┃"
echo -e "\033[01;31m┃\033[1;31m\033[1;34m[\033[1;37m 00 •\033[1;34m]\033[1;37m ➩  \033[1;33mSAIR  \033[1;32m<\033[1;33m<\033[1;31m< \033[0;31m                       \033[01;31m┃" 
			echo -e "\033[01;31m┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\033[0m"
			tput civis
			echo -ne "\033[1;31m┗━━━➤\033[1;32m ESCOLHA OPÇÃO DESEJADA\033[1;33m\033[1;31m\033[1;37m : ";
			read x
			tput cnorm
			clear
			case $x in
			1 | 01)
			fun_openssh
			;;
			2 | 02)
			fun_drop
			;;
			3 | 03)
			fun_openvpn
			;;
			4 | 04)
			fun_socks
			;;
                        5 | 05)
                        clear
			rustyproxy
			;;
			6 | 06)
			inst_ssl
			;;
			7 | 07)
			inst_ssl5
			;;
			8 | 08)
			tput reset
			clear
			slow_setup
			;;
			9 | 09)
			xraymanager
			;;
			10)
			v2raymanager
			;;
			11)
			echo -e "\E[44;1;37m             LIMPAR V2RAY              \E[0m"
			echo -e "\033[1;31mESSA FUNÇÃO É PARA LIBERAR MEMÓRIA EM DISCO COMO MEMÓRIA RAM \033[1;33m \033[1;32\033[0m"
			echo -e "\033[1;31mTenha em mente que ao executá-lo, se você tivesse estatísticas de consumo, \033[1;33m \033[1;32\033[0m"
			echo -e "\033[1;31meles serão zerados, não há perda de configurações ou do usuário \033[1;33m \033[1;32\033[0m"
			v2ray clean
			echo -ne "\n\033[1;31mENTER \033[1;33mpara retornar ao \033[1;32mMENU!\033[0m"; read
			;;
			12)
			clear
			menu
			;;
			0 | 00)
			clear
			menu
			;;
			*)
			echo -e "\033[1;31mOpcao invalida !\033[0m"
			sleep 2
			;;
			esac
		done
}
fun_conexao
